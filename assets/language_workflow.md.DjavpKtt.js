import{_ as a,c as s,o as n,aj as t}from"./chunks/framework.Bz2R-749.js";const u=JSON.parse('{"title":"Workflow 语法指南","description":"","frontmatter":{},"headers":[],"relativePath":"language/workflow.md","filePath":"language/workflow.md"}'),l={name:"language/workflow.md"};function o(i,e,r,p,c,d){return n(),s("div",null,[...e[0]||(e[0]=[t(`<h1 id="workflow-语法指南" tabindex="-1">Workflow 语法指南 <a class="header-anchor" href="#workflow-语法指南" aria-label="Permalink to “Workflow 语法指南”">​</a></h1><p><em>最后更新：2025-11-10 18:08 NZST · 执行者：Codex</em></p><p>Workflow 语法以 CNL（Controlled Natural Language）描述可补偿、可观测的业务流程。本指南面向策略作者与运营人员，覆盖关键字规则、配置块写法、完整示例与最佳实践。</p><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">​</a></h2><ul><li><a href="#基础语法">基础语法</a><ul><li><a href="#workflow-关键字与结构">Workflow 关键字与结构</a></li><li><a href="#step-定义与命名">Step 定义与命名</a></li><li><a href="#compensate-块语义">Compensate 块语义</a></li><li><a href="#retry-与-timeout-配置">Retry 与 Timeout 配置</a></li></ul></li><li><a href="#完整示例">完整示例</a><ul><li><a href="#线性订单流程">线性订单流程</a></li><li><a href="#补偿驱动的错误恢复">补偿驱动的错误恢复</a></li><li><a href="#timeout-配置示例">Timeout 配置示例</a></li><li><a href="#retry-策略示例">Retry 策略示例</a></li></ul></li><li><a href="#最佳实践">最佳实践</a><ul><li><a href="#何时编写-compensate">何时编写 Compensate</a></li><li><a href="#可恢复-workflow-设计指南">可恢复 Workflow 设计指南</a></li><li><a href="#effectcapability-声明要点">Effect/Capability 声明要点</a></li><li><a href="#常见错误与排查">常见错误与排查</a></li></ul></li></ul><h2 id="基础语法" tabindex="-1">基础语法 <a class="header-anchor" href="#基础语法" aria-label="Permalink to “基础语法”">​</a></h2><h3 id="workflow-关键字与结构" tabindex="-1">Workflow 关键字与结构 <a class="header-anchor" href="#workflow-关键字与结构" aria-label="Permalink to “Workflow 关键字与结构”">​</a></h3><ul><li>入口语法：在函数体内书写 <code>workflow:</code>，后续内容必须缩进两个空格。</li><li><code>workflow</code> 块以句点 <code>.</code> 结束，和其他语句保持一致的行尾句点规则。</li><li>Workflow 必须位于声明了 <code>It performs io ...</code> 的函数中，编译器会强制要求 IO 效果（错误码 E026）。</li><li>Workflow 至少包含一个 <code>step</code>，否则解析阶段直接报错。</li><li>Workflow 元数据（<code>retry</code>, <code>timeout</code>）写在 step 列表之后，继续沿用缩进块语义。</li></ul><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>To processOrder with input: Order, produce Result of Receipt with IO. It performs io with Http and Sql:</span></span>
<span class="line"><span>  workflow:</span></span>
<span class="line"><span>    step validate:</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span>  .</span></span></code></pre></div><h3 id="step-定义与命名" tabindex="-1">Step 定义与命名 <a class="header-anchor" href="#step-定义与命名" aria-label="Permalink to “Step 定义与命名”">​</a></h3><ul><li><code>step &lt;identifier&gt;:</code> 定义步骤，建议使用蛇形（<code>reserve_inventory</code>）或语义化短语（<code>charge_payment</code>）。</li><li>通过 <code>step foo depends on [&quot;bar&quot;, &quot;baz&quot;]:</code> 显式声明依赖，编译器会构建 DAG 并在运行时并发执行所有依赖已满足的步骤。</li><li>若省略 <code>depends on</code>，编译器会自动依赖上一个步骤，保持现有串行语义以便向后兼容。</li><li>Step 块内部可使用所有常规语句（<code>Let</code>, <code>Return</code>, <code>Match</code>, <code>start/await</code> 等）。</li><li>Step 的执行结果为最后一条语句的返回值；通常返回 <code>Result</code> 用于表达成功/失败。</li></ul><h4 id="显式依赖与并发执行" tabindex="-1">显式依赖与并发执行 <a class="header-anchor" href="#显式依赖与并发执行" aria-label="Permalink to “显式依赖与并发执行”">​</a></h4><ul><li>编译器在解析 <code>depends on [&quot;step_a&quot;, &quot;step_b&quot;]</code> 时会对名称执行静态校验，若引用未声明的 step，则触发 <strong>E029(WORKFLOW_UNKNOWN_STEP_DEPENDENCY)</strong>。</li><li>所有步骤会被映射到 <code>AsyncTaskRegistry</code> 的依赖图中：缺失依赖的节点立即进入 <code>ready</code> 队列，其他节点在依赖完成后自动解锁。</li><li>运行时使用 <code>CompletableFuture</code> + <code>ExecutorService</code>（线程池大小等于 CPU 核数，最小为 1）批量提交就绪任务；完全独立的步骤会并发执行。</li><li>若依赖图存在回路，解析阶段直接报错；运行时若检测到“无就绪节点但仍有未完成任务”，会抛出 <code>IllegalStateException(&quot;Deadlock detected&quot;)</code> 并终止 workflow。</li></ul><h4 id="补偿堆栈-lifo" tabindex="-1">补偿堆栈（LIFO） <a class="header-anchor" href="#补偿堆栈-lifo" aria-label="Permalink to “补偿堆栈（LIFO）”">​</a></h4><ul><li>AsyncTaskRegistry 按步骤完成顺序推入补偿堆栈；当某步骤失败时，会以 LIFO 顺序触发已完成步骤的 <code>compensate</code>，保证最新副作用最先撤销。</li><li>在并发场景中，同一批次的步骤完成顺序仍由线程池执行顺序决定，因此补偿顺序与真实提交顺序一致，不需显式声明优先级。</li></ul><h3 id="并发执行模型与限制" tabindex="-1">并发执行模型与限制 <a class="header-anchor" href="#并发执行模型与限制" aria-label="Permalink to “并发执行模型与限制”">​</a></h3><ul><li><strong>依赖图构建</strong>：parser 把每个 <code>step</code> 的显式/隐式依赖写入 Core IR，运行时在 <code>AsyncTaskRegistry</code> 内部构建 <code>DependencyGraph</code>。图节点使用 <code>LinkedHashSet</code> 保序，便于复现源程序声明顺序。</li><li><strong>调度实现</strong>：<code>WorkflowScheduler</code> 仅包装 <code>AsyncTaskRegistry.executeUntilComplete()</code>，真正的并发调度靠 <code>CompletableFuture.allOf</code> + 固定线程池（<code>ExecutorService</code>）批量提交就绪任务。</li><li><strong>循环检测</strong>：DependencyGraph 在 <code>addTask</code> 时执行 DFS 检测环路，发现时立即抛出 <code>IllegalArgumentException(&quot;Circular dependency detected ...&quot;)</code>。</li><li><strong>死锁检测</strong>：若仍有任务未完成但没有就绪节点，<code>executeUntilComplete</code> 会抛出 <code>IllegalStateException(&quot;Deadlock detected ...&quot;)</code>，并把已捕获的失败任务一并输送到调用方。</li><li><strong>缺省串行兼容</strong>：线程池大小为 1 时，调度器自动退化为串行执行；无 <code>depends on</code> 的旧 workflow 与 Phase 2.0 的行为保持一致。</li></ul><h3 id="compensate-块语义" tabindex="-1">Compensate 块语义 <a class="header-anchor" href="#compensate-块语义" aria-label="Permalink to “Compensate 块语义”">​</a></h3><ul><li><code>compensate:</code> 可选，但一旦步骤执行了 IO/Capability，将触发 <strong>E023(WORKFLOW_COMPENSATE_MISSING)</strong> 警告。</li><li>Compensate 必须返回 <code>Result&lt;Unit, ErrType&gt;</code>，其中 <code>ErrType</code> 与 step 主体的错误类型一致。类型不匹配会触发 <strong>E022</strong>。</li><li>Compensate 内禁止引入新的能力，违反时触发 <strong>E028(COMPENSATE_NEW_CAPABILITY)</strong>。</li><li>常见模式：在主体执行资源预留、计费、外部调用后，Compensate 对应释放、退款、撤销。</li></ul><h3 id="retry-与-timeout-配置" tabindex="-1">Retry 与 Timeout 配置 <a class="header-anchor" href="#retry-与-timeout-配置" aria-label="Permalink to “Retry 与 Timeout 配置”">​</a></h3><ul><li><code>retry:</code> 为缩进块，包含两条指令： <ul><li><code>max attempts: &lt;int&gt;.</code> （必须 &gt;0）</li><li><code>backoff: exponential|linear.</code></li></ul></li><li><code>timeout:</code> 为单行语句，格式 <code>timeout: &lt;seconds&gt; seconds.</code>，编译器会转换为毫秒。</li><li>Retry/Timeout 元数据存入 Core IR，并由 JVM emitter 生成重试循环代码，运行时执行。</li><li>配置示例：</li></ul><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>  retry:</span></span>
<span class="line"><span>    max attempts: 3.</span></span>
<span class="line"><span>    backoff: exponential.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  timeout: 45 seconds.</span></span></code></pre></div><h4 id="运行时重试行为" tabindex="-1">运行时重试行为 <a class="header-anchor" href="#运行时重试行为" aria-label="Permalink to “运行时重试行为”">​</a></h4><p>当工作流步骤失败时，运行时会按照以下流程执行重试：</p><ol><li><strong>失败检测</strong>：步骤抛出异常时，AsyncTaskRegistry 捕获异常并检查 RetryPolicy</li><li><strong>尝试次数检查</strong>： <ul><li>如果当前尝试次数 &lt; max attempts，执行重试</li><li>如果达到 max attempts，抛出 MaxRetriesExceededException</li></ul></li><li><strong>Backoff 计算</strong>： <ul><li><strong>Exponential backoff</strong>：<code>delay = baseDelay * 2^(attempt-1) + jitter</code></li><li><strong>Linear backoff</strong>：<code>delay = baseDelay * attempt + jitter</code></li><li><strong>Jitter</strong>：随机值在 <code>[0, baseDelay/2)</code> 范围内，使用 DeterminismContext 确保重放一致性</li><li><strong>Base delay</strong>：默认 1000ms（1秒）</li></ul></li><li><strong>延迟调度</strong>：将重试任务加入 DelayedTask 队列，等待 timer 触发</li><li><strong>事件记录</strong>：记录 RETRY_SCHEDULED 事件，包含 attemptNumber、backoffDelayMs、failureReason</li><li><strong>重放一致性</strong>：重放时使用事件日志中记录的 backoff_delay_ms，而不是重新计算</li></ol><h4 id="backoff-计算示例" tabindex="-1">Backoff 计算示例 <a class="header-anchor" href="#backoff-计算示例" aria-label="Permalink to “Backoff 计算示例”">​</a></h4><p>假设 baseDelay = 1000ms，max attempts = 3：</p><p><strong>Exponential backoff</strong>：</p><ul><li>第1次失败 → 第2次尝试：delay = 1000 * 2^0 + jitter = 1000ms ~ 1500ms</li><li>第2次失败 → 第3次尝试：delay = 1000 * 2^1 + jitter = 2000ms ~ 2500ms</li><li>第3次失败 → 抛出异常</li></ul><p><strong>Linear backoff</strong>：</p><ul><li>第1次失败 → 第2次尝试：delay = 1000 * 1 + jitter = 1000ms ~ 1500ms</li><li>第2次失败 → 第3次尝试：delay = 1000 * 2 + jitter = 2000ms ~ 2500ms</li><li>第3次失败 → 抛出异常</li></ul><h4 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to “最佳实践”">​</a></h4><ol><li><p><strong>选择 max attempts</strong>：</p><ul><li>瞬时故障（网络抖动）：2-3 次</li><li>外部服务超时：3-5 次</li><li>避免设置过高，导致工作流长时间悬挂</li></ul></li><li><p><strong>选择 backoff 策略</strong>：</p><ul><li><strong>Exponential</strong>：适合外部服务过载场景，快速减轻压力</li><li><strong>Linear</strong>：适合瞬时故障，保持稳定重试间隔</li></ul></li><li><p><strong>重试与补偿的配合</strong>：</p><ul><li>Retry 用于处理瞬时故障（自动恢复）</li><li>Compensate 用于处理永久失败（业务回滚）</li><li>达到 max attempts 后，工作流失败，触发 Compensate 流程</li></ul></li><li><p><strong>超时与重试的协调</strong>：</p><ul><li>Timeout 应设置为合理值，避免单次尝试耗时过长</li><li>总超时时间 ≈ timeout * max attempts * average backoff</li><li>示例：timeout = 30s, max attempts = 3, exponential backoff → 总时间约 2-3 分钟</li></ul></li></ol><h2 id="完整示例" tabindex="-1">完整示例 <a class="header-anchor" href="#完整示例" aria-label="Permalink to “完整示例”">​</a></h2><h3 id="线性订单流程" tabindex="-1">线性订单流程 <a class="header-anchor" href="#线性订单流程" aria-label="Permalink to “线性订单流程”">​</a></h3><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>This module is examples.workflow.linear_order.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To processOrder, produce Result of Text with IO. It performs io:</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  workflow:</span></span>
<span class="line"><span>    step validate:</span></span>
<span class="line"><span>      return ok of &quot;order validated&quot;.</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    step reserve_inventory:</span></span>
<span class="line"><span>      return ok of &quot;inventory reserved&quot;.</span></span>
<span class="line"><span>      </span></span>
<span class="line"><span>      compensate:</span></span>
<span class="line"><span>        return ok of &quot;inventory released&quot;.</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    step charge_payment:</span></span>
<span class="line"><span>      return ok of &quot;payment charged&quot;.</span></span>
<span class="line"><span>      </span></span>
<span class="line"><span>      compensate:</span></span>
<span class="line"><span>        return ok of &quot;payment refunded&quot;.</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    timeout: 30 seconds.</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  .</span></span></code></pre></div><ul><li>所有 Step 串行执行，默认依赖上一个 Step 的完成结果。</li><li>Timeout 保护整个流程，若 30 秒内未完成，即触发 WorkflowScheduler 的超时取消。</li></ul><h3 id="补偿驱动的错误恢复" tabindex="-1">补偿驱动的错误恢复 <a class="header-anchor" href="#补偿驱动的错误恢复" aria-label="Permalink to “补偿驱动的错误恢复”">​</a></h3><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>This module is examples.workflow.error_recovery.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To handleErrors, produce Result of Text with IO. It performs io:</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  workflow:</span></span>
<span class="line"><span>    step prepare:</span></span>
<span class="line"><span>      return ok of &quot;prepared&quot;.</span></span>
<span class="line"><span>      </span></span>
<span class="line"><span>      compensate:</span></span>
<span class="line"><span>        return ok of &quot;cleanup prepared&quot;.</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    step execute:</span></span>
<span class="line"><span>      return err of &quot;execution failed&quot;.</span></span>
<span class="line"><span>      </span></span>
<span class="line"><span>      compensate:</span></span>
<span class="line"><span>        return ok of &quot;rollback executed&quot;.</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  .</span></span></code></pre></div><ul><li>第二个 Step 返回 <code>err</code> 触发 compensations，AsyncTaskRegistry 将执行 <code>rollback executed</code> 以还原状态。</li></ul><h3 id="timeout-配置示例" tabindex="-1">Timeout 配置示例 <a class="header-anchor" href="#timeout-配置示例" aria-label="Permalink to “Timeout 配置示例”">​</a></h3><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>To syncExternalResources, produce Result of Unit with IO. It performs io with Http and Secrets:</span></span>
<span class="line"><span>  workflow:</span></span>
<span class="line"><span>    step fetch_remote:</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    step reconcile_cache:</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    timeout: 120 seconds.</span></span>
<span class="line"><span>  .</span></span></code></pre></div><ul><li>Timeout 值会在 JVM emitter 中转换为 <code>long workflowTimeoutMs</code>，WorkflowScheduler 轮询时负责中断。</li><li>结合 <code>Secrets</code> 能力声明，表明任务可能访问凭证管理器。</li></ul><h3 id="retry-策略示例" tabindex="-1">Retry 策略示例 <a class="header-anchor" href="#retry-策略示例" aria-label="Permalink to “Retry 策略示例”">​</a></h3><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>To capturePayment, produce Result of Receipt with IO. It performs io with Http:</span></span>
<span class="line"><span>  workflow:</span></span>
<span class="line"><span>    step invoke_gateway:</span></span>
<span class="line"><span>      return Http.charge(paymentRequest).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    retry:</span></span>
<span class="line"><span>      max attempts: 4.</span></span>
<span class="line"><span>      backoff: linear.</span></span>
<span class="line"><span>  .</span></span></code></pre></div><ul><li>Retry 对整个 workflow 生效，compiler 确保 <code>max attempts</code> 与 <code>backoff</code> 均已填写。</li><li>Phase 2.1 JVM emitter以注释保留策略，后续 runtime 将据此包装 <code>WorkflowScheduler</code> 调用。</li></ul><h3 id="并发模式示例" tabindex="-1">并发模式示例 <a class="header-anchor" href="#并发模式示例" aria-label="Permalink to “并发模式示例”">​</a></h3><ul><li><strong>Fan-out 模式</strong>（<code>quarkus-policy-api/src/main/resources/policies/examples/fanout-concurrent.aster</code>）：<code>init_context</code> 完成后，<code>enrich_customer</code> 与 <code>enrich_order</code> 并发执行，<code>consolidate</code> 依赖两者汇总结果，演示通过 <code>depends on [&quot;init_context&quot;]</code> 解锁多个并行节点。</li><li><strong>Diamond 模式</strong>（<code>quarkus-policy-api/src/main/resources/policies/examples/diamond-merge.aster</code>）：<code>init_payload</code> → 两条并行分支（<code>score_risk</code> / <code>fetch_offer</code>）→ <code>join_insights</code> → <code>finalize</code>，展示显式依赖在复杂拓扑中的可读性，并结合 <code>timeout</code> 参数。</li><li><strong>串行兼容模式</strong>（<code>quarkus-policy-api/src/main/resources/policies/examples/serial-compatible.aster</code>）：未写 <code>depends on</code> 的 workflow 仍按声明顺序执行，以便迁移旧流程时无需一次性改完所有步骤。</li></ul><h2 id="最佳实践-1" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践-1" aria-label="Permalink to “最佳实践”">​</a></h2><h3 id="何时编写-compensate" tabindex="-1">何时编写 Compensate <a class="header-anchor" href="#何时编写-compensate" aria-label="Permalink to “何时编写 Compensate”">​</a></h3><ul><li><strong>外部资源状态改变</strong>：库存锁定、支付扣款、异步任务排队等都需要补偿。</li><li><strong>慢速依赖</strong>：调用第三方接口失败概率高时，先写补偿以便快速回滚。</li><li><strong>并发步骤</strong>：虽然 Phase 2.1 尚未暴露并行 DSL，仍建议为潜在并发步骤提前设计补偿接口。</li></ul><h3 id="可恢复-workflow-设计指南" tabindex="-1">可恢复 Workflow 设计指南 <a class="header-anchor" href="#可恢复-workflow-设计指南" aria-label="Permalink to “可恢复 Workflow 设计指南”">​</a></h3><ul><li><strong>Result-first</strong>：步骤返回 <code>Result&lt;Ok, Err&gt;</code>，将错误类型用于补偿和汇总。</li><li><strong>最小副作用</strong>：在单个 step 中完成对同一系统的操作，避免横跨多个 step 的共享事务。</li><li><strong>Idempotent Compensate</strong>：补偿逻辑应当可重复执行，保证 WorkflowScheduler 在重试/重放时安全。</li><li><strong>粒度清晰</strong>：将校验、资源预留、外部调用拆分为独立 step，提升可观测性。</li></ul><h3 id="effect-capability-声明要点" tabindex="-1">Effect/Capability 声明要点 <a class="header-anchor" href="#effect-capability-声明要点" aria-label="Permalink to “Effect/Capability 声明要点”">​</a></h3><ul><li>函数层需声明 <code>It performs io</code> 才能使用 workflow；若缺失将触发 <strong>E026</strong>。</li><li>在 <code>It performs io with Http and Sql.</code> 中列举所有会在 step/compensate 里调用的能力。漏写会触发 <strong>E027</strong>。</li><li>Compensate 只能复用主体用过的能力，新增能力会触发 <strong>E028</strong>；必要时将副作用迁回主体。</li></ul><h3 id="常见错误与排查" tabindex="-1">常见错误与排查 <a class="header-anchor" href="#常见错误与排查" aria-label="Permalink to “常见错误与排查”">​</a></h3><table tabindex="0"><thead><tr><th>错误码</th><th>触发原因</th><th>排查步骤</th></tr></thead><tbody><tr><td>E022</td><td>Compensate 返回类型与主体错误类型不匹配</td><td>确认主体 <code>Result</code> 的 <code>Err</code> 类型，并让补偿返回 <code>Result&lt;Unit, Err&gt;</code></td></tr><tr><td>E023</td><td>带副作用的 step 未定义补偿</td><td>检查该 step 是否使用 IO/Capability；如需跳过，在设计上保证幂等性并添加说明</td></tr><tr><td>E024</td><td><code>max attempts</code> ≤ 0</td><td>改为正整数</td></tr><tr><td>E025</td><td>Timeout 非正值或缺少单位</td><td>使用 <code>timeout: &lt;n&gt; seconds.</code> 格式</td></tr><tr><td>E026</td><td>函数缺少 <code>It performs io</code></td><td>在函数头部添加 <code>It performs io with ...</code></td></tr><tr><td>E027</td><td>未在函数头声明使用到的 capability</td><td>将 <code>Http</code>, <code>Sql</code>, <code>Secrets</code> 等加入 <code>It performs io with ...</code></td></tr><tr><td>E028</td><td>Compensate 引入新 capability</td><td>将相关调用移到主体或同步在主体中声明该 capability</td></tr></tbody></table><p>遵循以上语法与实践，可确保 workflow 程序在编译期通过解析、类型检查与效果/能力校验，并在运行时获得清晰的补偿与调度语义。</p>`,58)])])}const f=a(l,[["render",o]]);export{u as __pageData,f as default};
