import{_ as a,c as i,o as l,aj as s}from"./chunks/framework.Bz2R-749.js";const h=JSON.parse('{"title":"Lambdas & Closures (Design Draft)","description":"","frontmatter":{},"headers":[],"relativePath":"reference/lambdas.md","filePath":"reference/lambdas.md"}'),t={name:"reference/lambdas.md"};function o(n,e,r,d,c,p){return l(),i("div",null,[...e[0]||(e[0]=[s(`<h1 id="lambdas-closures-design-draft" tabindex="-1">Lambdas &amp; Closures (Design Draft) <a class="header-anchor" href="#lambdas-closures-design-draft" aria-label="Permalink to “Lambdas &amp; Closures (Design Draft)”">​</a></h1><p>Status: Draft | Last updated: 2025-10-07 12:06 NZST | Maintainer: Codex</p><p>This document outlines a minimal design to add first-class function values to the Core IR and JVM emitter. The goals are predictable lowering, simple runtime interop, and an incremental path that doesn’t block existing features.</p><h2 id="goals" tabindex="-1">Goals <a class="header-anchor" href="#goals" aria-label="Permalink to “Goals”">​</a></h2><ul><li>First-class function values: pass as arguments, return from functions, store in data fields.</li><li>Support simple closures that capture immutable locals from the defining scope.</li><li>Keep the surface syntax natural (CNL), but start with IR support first.</li><li>JVM emission that works without invokedynamic; use plain classes + interfaces.</li></ul><h2 id="ir-additions" tabindex="-1">IR Additions <a class="header-anchor" href="#ir-additions" aria-label="Permalink to “IR Additions”">​</a></h2><ul><li>Type: <code>FuncType { params: Type[], ret: Type }</code><ul><li>Printable as <code>(A, B) -&gt; C</code> in pretty printer.</li></ul></li><li>Expr: <code>Lambda { params: Param[], ret: Type, body: Block, captures?: string[] }</code><ul><li><code>captures</code> is populated during lowering via capture analysis.</li></ul></li><li>Expr: <code>Call</code> already exists; allow <code>target</code> to be any <code>Expr</code> of <code>FuncType</code>.</li></ul><p>Notes:</p><ul><li>This does not introduce higher-kinded types or generics on lambdas; those can come later.</li></ul><h2 id="lowering" tabindex="-1">Lowering <a class="header-anchor" href="#lowering" aria-label="Permalink to “Lowering”">​</a></h2><ul><li>Surface syntax (future): <ul><li>Inline lambda: <code>Return (x) -&gt; x + 1.</code></li><li>Named function as value: <code>Return id.</code> (already supported as a Name literal)</li></ul></li><li>For now: enable IR-only by allowing tests/fixtures to inject <code>Lambda</code> nodes.</li><li>Capture analysis: <ul><li>Determine free variables of the lambda body not bound by its params.</li><li>Validate they are immutable locals from the enclosing scope.</li><li>Populate <code>captures</code> in a stable declaration order.</li></ul></li></ul><h2 id="runtime-interfaces" tabindex="-1">Runtime Interfaces <a class="header-anchor" href="#runtime-interfaces" aria-label="Permalink to “Runtime Interfaces”">​</a></h2><ul><li>Add simple functional interfaces in <code>aster-runtime</code>: <ul><li><code>Fn1&lt;T,R&gt; { R apply(T a); }</code></li><li><code>Fn2&lt;A,B,R&gt; { R apply(A a, B b); }</code></li><li>Extend as needed; start with <code>Fn1</code>.</li></ul></li><li>Map <code>FuncType</code> arity <code>N</code> to <code>FnN</code> in JVM emission.</li></ul><h2 id="jvm-emission" tabindex="-1">JVM Emission <a class="header-anchor" href="#jvm-emission" aria-label="Permalink to “JVM Emission”">​</a></h2><ul><li>For each <code>Lambda</code> expression: <ul><li>Synthesize a final class (e.g., <code>\${enclosing}_lambda$&lt;seq&gt;</code>) with: <ul><li>Final fields for each captured variable.</li><li>A constructor taking captured values and storing them.</li><li>An <code>apply</code> method matching <code>FnN</code> to evaluate the lambda body.</li></ul></li><li>Emit a <code>new</code> of that class at the lambda site, passing captures.</li><li>The value’s static type is the corresponding <code>FnN</code> interface.</li></ul></li><li>Calls: <ul><li>If target has <code>FuncType</code> of arity <code>N</code>, emit <code>invokeinterface FnN.apply</code>.</li></ul></li><li>Interop: <ul><li>In the future, provide adapters to Java <code>java.util.function.*</code> where helpful.</li></ul></li></ul><h2 id="validation-plan" tabindex="-1">Validation Plan <a class="header-anchor" href="#validation-plan" aria-label="Permalink to “Validation Plan”">​</a></h2><ul><li>Golden/ASM fixtures: <ul><li>Pass a simple <code>(x) -&gt; x</code> into <code>List.map</code> and verify bytecode.</li><li>Closure capturing an outer <code>prefix</code> string used in the body.</li></ul></li><li>Truffle: <ul><li>Add <code>LambdaNode</code> and <code>CallFunctionNode</code> to execute closures.</li></ul></li></ul><h2 id="out-of-scope-initial" tabindex="-1">Out of Scope (Initial) <a class="header-anchor" href="#out-of-scope-initial" aria-label="Permalink to “Out of Scope (Initial)”">​</a></h2><ul><li>Partial application, currying, higher-kinded generics, and invokedynamic.</li><li>Precise escape analysis for captured variables (always heap fields initially).</li></ul><h2 id="open-questions" tabindex="-1">Open Questions <a class="header-anchor" href="#open-questions" aria-label="Permalink to “Open Questions”">​</a></h2><ul><li>Surface syntax for multiple parameters in CNL without punctuation.</li><li>Whether to allow capturing mutable vars (likely no; require immutability).</li><li>Proposed CNL Syntax (Not Implemented)</li></ul><p>To keep the CNL surface natural, one option is to model inline lambdas with a compact phrase that mirrors function headers, for example:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Return a function with x: Text, produce Text:</span></span>
<span class="line"><span>  Return Text.concat(&quot;Hi, &quot;, x).</span></span></code></pre></div><p>Or a short-form inline expression:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Return (x: Text) =&gt; Text.concat(&quot;Hi, &quot;, x).</span></span></code></pre></div><p>Notes:</p><ul><li>The first form reuses existing header words (with/produce) and block shape.</li><li>The short-form introduces a minimal <code>=&gt;</code> token for expression lambdas.</li><li>Both forms lower to <code>Core.Lambda</code> with <code>captures</code> derived from free variables. Block form is implemented; short-form parsing is supported for simple cases and infers common return types.</li></ul><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to “Usage”">​</a></h2><p>Two forms are supported in CNL:</p><ul><li>Block form (with a body block):</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Let f be function with x: Text, produce Text:</span></span>
<span class="line"><span>  Return Text.concat(pfx, x).</span></span>
<span class="line"><span>Return f(&quot;there&quot;).</span></span></code></pre></div><ul><li>Short form (inline expression):</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Let g be (y: Text) =&gt; Text.concat(&quot;2&quot;, y).</span></span>
<span class="line"><span>Return g(&quot;b&quot;).</span></span></code></pre></div><p>Notes:</p><ul><li>Block-form lambdas end the header with a colon, followed by an indented block.</li><li>Short-form return types are inferred for common cases: Text.concat → Text, (+) → Int, not/&lt;/&gt;/== → Bool; otherwise Unknown.</li><li>Both forms lower to Core.Lambda with captures derived from free variables.</li></ul><h2 id="verification" tabindex="-1">Verification <a class="header-anchor" href="#verification" aria-label="Permalink to “Verification”">​</a></h2><p>From Core JSON (extended lambda fixtures):</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>npm run verify:asm:lambda</span></span></code></pre></div><p>From CNL examples end-to-end (parse → lower → emit ASM → javap):</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>npm run verify:asm:lambda:cnl</span></span></code></pre></div><p>This emits classes for the lambda examples in <code>test/cnl/examples/</code> and runs <code>javap -v</code> on all emitted <code>.class</code> files.</p>`,41)])])}const m=a(t,[["render",o]]);export{h as __pageData,m as default};
