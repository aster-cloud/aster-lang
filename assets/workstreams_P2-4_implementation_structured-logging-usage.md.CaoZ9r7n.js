import{_ as o,c,o as r,aj as d}from"./chunks/framework.Bz2R-749.js";const p=JSON.parse('{"title":"结构化日志系统使用指引","description":"","frontmatter":{},"headers":[],"relativePath":"workstreams/P2-4/implementation/structured-logging-usage.md","filePath":"workstreams/P2-4/implementation/structured-logging-usage.md"}'),a={name:"workstreams/P2-4/implementation/structured-logging-usage.md"};function t(l,e,i,s,n,g){return r(),c("div",null,[...e[0]||(e[0]=[d('<h1 id="结构化日志系统使用指引" tabindex="-1">结构化日志系统使用指引 <a class="header-anchor" href="#结构化日志系统使用指引" aria-label="Permalink to “结构化日志系统使用指引”">​</a></h1><p>日期：2025-10-08 14:50 NZST<br> 执行者：Codex</p><h2 id="logger-api" tabindex="-1">Logger API <a class="header-anchor" href="#logger-api" aria-label="Permalink to “Logger API”">​</a></h2><ul><li><code>createLogger(component: string)</code>：根据 <code>LOG_LEVEL</code> 环境变量创建命名组件的 <code>Logger</code> 实例；支持的级别为 <code>DEBUG/INFO/WARN/ERROR</code>，默认为 <code>INFO</code>。（参考 <code>src/utils/logger.ts:1</code>）</li><li><code>logger.debug/info/warn(message, meta?)</code>：输出 JSON 日志，<code>meta</code> 字段会被展开到顶层，便于下游检索。（参考 <code>src/utils/logger.ts:10</code>）</li><li><code>logger.error(message, error?, meta?)</code>：在保留堆栈与错误信息的同时附加自定义元数据。（参考 <code>src/utils/logger.ts:22</code>）</li><li><code>logPerformance({ component, operation, duration, metadata })</code>：快速记录性能指标，内部使用 <code>Logger(&#39;performance&#39;)</code>，自动包含 <code>duration_ms</code>。（参考 <code>src/utils/logger.ts:47</code>）</li></ul><h2 id="环境变量与级别" tabindex="-1">环境变量与级别 <a class="header-anchor" href="#环境变量与级别" aria-label="Permalink to “环境变量与级别”">​</a></h2><ul><li><code>LOG_LEVEL</code>：接受 <code>DEBUG/INFO/WARN/ERROR</code>（大小写不敏感），决定 <code>Logger</code> 输出的最低级别。（参考 <code>src/utils/logger.ts:57</code>）</li><li>建议在开发环境设为 <code>DEBUG</code> 以启用 <code>parser</code> 等模块的调试日志；生产默认保持 <code>INFO</code> 避免噪声。</li></ul><h2 id="集成示例" tabindex="-1">集成示例 <a class="header-anchor" href="#集成示例" aria-label="Permalink to “集成示例”">​</a></h2><ul><li>类型检查入口在 <code>src/typecheck.ts:139</code> 使用 <code>createLogger(&#39;typecheck&#39;)</code> 打点模块开始/结束，并通过 <code>logPerformance</code> 记录耗时与诊断数量。</li><li>类型等值检查 <code>tEquals</code> 将原有 <code>console.warn</code> 替换为 <code>typecheckLogger.warn</code>，在元数据中附上未处理类型（<code>src/typecheck.ts:62</code>）。</li><li>解析器调试日志走向 <code>parserLogger.debug</code>，并保留嵌套深度信息（<code>src/parser.ts:59</code>），与环境变量 <code>ASTER_DEBUG_TYPES=1</code> 配合使用。</li></ul><h2 id="扩展指引" tabindex="-1">扩展指引 <a class="header-anchor" href="#扩展指引" aria-label="Permalink to “扩展指引”">​</a></h2><ul><li>处理 <code>DiagnosticError</code> 或 <code>createError</code> 生成的结构化错误时，可将 <code>code/timestamp/location</code> 放入 <code>meta</code>，保持诊断与日志统一编号。</li><li>执行性能敏感操作（如 LSP 索引构建）时，可在操作前后记录 <code>performance.now()</code> 差值并调用 <code>logPerformance</code>。</li><li>若需要保留面向 LSP 客户端的 <code>connection.console</code> 输出，可在调用后追加 <code>logger.info</code> 以同步写入集中日志。</li></ul><h2 id="验证流程" tabindex="-1">验证流程 <a class="header-anchor" href="#验证流程" aria-label="Permalink to “验证流程”">​</a></h2><ol><li><code>npm run typecheck</code> 确认 TypeScript 编译通过。</li><li><code>npm run test</code> 观察黄金测试期间输出的 JSON 日志，确认性能指标与诊断数量字段存在。</li><li><code>LOG_LEVEL=DEBUG node dist/scripts/typecheck-cli.js &lt;文件&gt;</code> 校验命令行工具输出结构化日志；如需 parser 调试信息，可额外设置 <code>ASTER_DEBUG_TYPES=1</code>。</li></ol>',12)])])}const h=o(a,[["render",t]]);export{p as __pageData,h as default};
