import{_ as o,c as l,o as c,aj as a}from"./chunks/framework.Bz2R-749.js";const h=JSON.parse('{"title":"Workflow 实现细节","description":"","frontmatter":{},"headers":[],"relativePath":"dev/workflow-implementation.md","filePath":"dev/workflow-implementation.md"}'),r={name:"dev/workflow-implementation.md"};function t(i,e,d,s,n,p){return c(),l("div",null,[...e[0]||(e[0]=[a('<h1 id="workflow-实现细节" tabindex="-1">Workflow 实现细节 <a class="header-anchor" href="#workflow-实现细节" aria-label="Permalink to “Workflow 实现细节”">​</a></h1><p><em>最后更新：2025-11-10 18:08 NZST · 执行者：Codex</em></p><p>本文面向编译器与运行时贡献者，概述 Phase 2.1 Workflow 语言特性的实现方式，涵盖 parser、Core IR、类型/效果系统以及 JVM runtime。</p><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">​</a></h2><ul><li><a href="#parser-实现">Parser 实现</a><ul><li><a href="#parseworkflow-与-parsestep">parseWorkflow 与 parseStep</a></li><li><a href="#关键字与缩进管理">关键字与缩进管理</a></li><li><a href="#ast-节点构造与元数据">AST 节点构造与元数据</a></li></ul></li><li><a href="#core-ir-设计">Core IR 设计</a><ul><li><a href="#coreworkflowcorestep-节点">Core.Workflow/Core.Step 节点</a></li><li><a href="#降级逻辑ast-core">降级逻辑（AST → Core）</a></li><li><a href="#effectcaps-聚合策略">EffectCaps 聚合策略</a></li></ul></li><li><a href="#type-system-扩展">Type System 扩展</a><ul><li><a href="#workflowte-类型编码">Workflow&lt;T,E&gt; 类型编码</a></li><li><a href="#typecheckworkflowtypecheckstep">typecheckWorkflow/typecheckStep</a></li><li><a href="#compensate-约束与效果缓存优化">Compensate 约束与效果缓存优化</a></li></ul></li><li><a href="#effect-inference">Effect Inference</a><ul><li><a href="#effectcollector-扩展">EffectCollector 扩展</a></li><li><a href="#capability-验证机制">Capability 验证机制</a></li><li><a href="#compensate-capability-约束">Compensate capability 约束</a></li></ul></li><li><a href="#runtime-集成">Runtime 集成</a><ul><li><a href="#jvm-emitter">JVM Emitter</a></li><li><a href="#workflownode-接口">WorkflowNode 接口</a></li><li><a href="#asynctaskregistrydependencygraphworkflowscheduler">AsyncTaskRegistry/DependencyGraph/WorkflowScheduler</a></li></ul></li></ul><h2 id="parser-实现" tabindex="-1">Parser 实现 <a class="header-anchor" href="#parser-实现" aria-label="Permalink to “Parser 实现”">​</a></h2><h3 id="parseworkflow-与-parsestep" tabindex="-1">parseWorkflow 与 parseStep <a class="header-anchor" href="#parseworkflow-与-parsestep" aria-label="Permalink to “parseWorkflow 与 parseStep”">​</a></h3><ul><li>入口位于 <code>src/parser/expr-stmt-parser.ts</code>，<code>parseStatement</code> 检测到 <code>KW.WORKFLOW</code> 时委派给 <code>parseWorkflow</code>。</li><li><code>parseWorkflow</code> 流程： <ol><li>消耗 <code>workflow:</code> 与换行、<code>INDENT</code> token。</li><li>循环解析 <code>step</code>，最少 1 个，存入 <code>StepStmt[]</code>。</li><li>解析可选 <code>retry</code> 与 <code>timeout</code>，复用公共错误处理器。</li><li>验证 <code>DEDENT</code>，结尾调用 <code>expectPeriodEnd</code>。</li></ol></li><li><code>parseStep</code> 负责： <ul><li>捕获 <code>step &lt;identifier&gt;</code>，可选 <code>depends on [&quot;a&quot;, &quot;b&quot;]</code> 子句；依赖列表必须是字符串数组，解析出 <code>string[]</code> 写入 AST。</li><li>构造 <code>Node.Step</code>，在检测到 <code>compensate:</code> 时再解析一个 <code>Block</code> 并附加。</li><li>若显式依赖缺失或语法错误，直接抛出 <code>error(&quot;Expected &#39;[&#39; after &#39;depends on&#39;&quot;)</code>（<code>src/parser/expr-stmt-parser.ts:419</code>），确保诊断精确到语法位置。</li></ul></li></ul><h3 id="关键字与缩进管理" tabindex="-1">关键字与缩进管理 <a class="header-anchor" href="#关键字与缩进管理" aria-label="Permalink to “关键字与缩进管理”">​</a></h3><ul><li>Parser 使用 <code>kwParts</code> 将多词关键字拆分为 token 序列；Phase 2.1.6 引入常量缓存（如 <code>WAIT_FOR_PARTS</code>、<code>MAX_ATTEMPTS_PARTS</code>）以避免频繁分配。</li><li>所有嵌套块统一使用 <code>INDENT</code>/<code>DEDENT</code> token：<code>workflow</code>、<code>step</code>、<code>retry</code> 块均强制缩进，<code>timeout</code> 为单行语句无需 <code>INDENT</code>。</li><li><code>ctx.consumeNewlines()</code> 在 step、retry、timeout 之间清理空行，保证语句对齐。</li></ul><h3 id="ast-节点构造与元数据" tabindex="-1">AST 节点构造与元数据 <a class="header-anchor" href="#ast-节点构造与元数据" aria-label="Permalink to “AST 节点构造与元数据”">​</a></h3><ul><li><code>Node.Workflow</code>/<code>Node.Step</code> 在 <code>src/ast.ts</code> 定义，构造后调用 <code>assignSpan</code>/<code>assignSpanFromTokens</code> 将源位置信息附加到 <code>span</code> 字段。</li><li>Parser 在每个语句完成后调用 <code>lastConsumedToken</code> 取得结束位置，确保后续诊断（例如 E022/E025）能精确定位。</li></ul><h2 id="core-ir-设计" tabindex="-1">Core IR 设计 <a class="header-anchor" href="#core-ir-设计" aria-label="Permalink to “Core IR 设计”">​</a></h2><h3 id="core-workflow-core-step-节点" tabindex="-1">Core.Workflow/Core.Step 节点 <a class="header-anchor" href="#core-workflow-core-step-节点" aria-label="Permalink to “Core.Workflow/Core.Step 节点”">​</a></h3><ul><li>定义于 <code>src/core_ir.ts</code>，Workflow 结构包含： <ul><li><code>steps: Core.Step[]</code></li><li><code>effectCaps: CapabilityKind[]</code></li><li><code>retry?: RetryPolicy</code></li><li><code>timeout?: Timeout</code></li><li><code>dependencies: Map&lt;string, string[]&gt;</code>（Phase 2.4 新增：保留 AST 层的显式依赖）</li></ul></li><li>Step 结构包含：<code>name</code>, <code>body: Core.Block</code>, <code>effectCaps</code>, 可选 <code>compensate</code>, <code>dependsOn: string[]</code>。</li></ul><h3 id="降级逻辑-ast-→-core" tabindex="-1">降级逻辑（AST → Core） <a class="header-anchor" href="#降级逻辑-ast-→-core" aria-label="Permalink to “降级逻辑（AST → Core）”">​</a></h3><ul><li><code>lower_to_core.ts</code> 中的 <code>lowerWorkflow</code>/<code>lowerStep</code>： <ul><li>将 <code>Node.Step</code> 降级为 <code>Core.Step</code>，递归处理 <code>Block</code>。</li><li>复制 retry/timeout 元数据。</li><li>通过 <code>withOrigin</code> 将 <code>span</code> 映射为 <code>origin</code>，方便类型/效果诊断。</li></ul></li></ul><h3 id="effectcaps-聚合策略" tabindex="-1">EffectCaps 聚合策略 <a class="header-anchor" href="#effectcaps-聚合策略" aria-label="Permalink to “EffectCaps 聚合策略”">​</a></h3><ul><li><code>lowerStep</code> 调用 <code>collectCapabilitiesFromBlock</code> 对主体与补偿块分别遍历 <code>Core.Block</code>，根据 <code>inferCapabilityFromName</code> 推断 <code>CapabilityKind</code>。</li><li><code>mergeCapabilitySets</code> 保持首次出现顺序并去重，Workflow 层将 Step 的 capability 集合合并，用于： <ul><li>Typechecker 快速判断是否已有 IO 之外的非 CPU 能力。</li><li>Effect inference 与 runtime manifest（未来扩展）。</li></ul></li></ul><h2 id="type-system-扩展" tabindex="-1">Type System 扩展 <a class="header-anchor" href="#type-system-扩展" aria-label="Permalink to “Type System 扩展”">​</a></h2><h3 id="workflow-t-e-类型编码" tabindex="-1">Workflow&lt;T,E&gt; 类型编码 <a class="header-anchor" href="#workflow-t-e-类型编码" aria-label="Permalink to “Workflow&lt;T,E&gt; 类型编码”">​</a></h3><ul><li><code>typecheckWorkflow</code> 返回 <code>TypeApp(&#39;Workflow&#39;, [ResultType, EffectType])</code>，其中： <ul><li><code>ResultType</code> 来源于最后一个 step 的返回值（Unknown 时沿用 lattice）。</li><li><code>EffectType</code> 基于 workflow + step 的 effect/capability 推断。</li></ul></li></ul><h3 id="typecheckworkflow-typecheckstep" tabindex="-1">typecheckWorkflow/typecheckStep <a class="header-anchor" href="#typecheckworkflow-typecheckstep" aria-label="Permalink to “typecheckWorkflow/typecheckStep”">​</a></h3><ul><li><code>typecheckStep</code>： <ul><li>调用 <code>typecheckBlock</code> 推导 step 主体类型。</li><li><code>collectEffects</code> 统计 step 主体的 IO/CPU 行为，用于补偿缺失告警。</li><li>若存在 <code>compensate</code>，调用 <code>validateCompensateBlock</code> 校验返回类型。</li></ul></li><li>Phase 2.1.6 新增 <code>stepEffects</code> 缓存：<code>typecheckWorkflow</code> 在遍历 steps 时传入 Map，缓存 <code>collectEffects</code> 的结果，供后续效果推断复用。</li></ul><h3 id="compensate-约束与效果缓存优化" tabindex="-1">Compensate 约束与效果缓存优化 <a class="header-anchor" href="#compensate-约束与效果缓存优化" aria-label="Permalink to “Compensate 约束与效果缓存优化”">​</a></h3><ul><li><code>validateCompensateBlock</code> 强制补偿返回 <code>Result&lt;Unit, Err&gt;</code>，错误类型需与主体匹配。</li><li><code>stepHasSideEffects</code> 检查 step 主体 <code>effects</code> 集与 capability 声明，若检测到 IO/非 CPU 能力且缺少补偿，发出 E023。</li><li><code>workflowEffectType</code> 现可复用缓存的 effect 集合： <ul><li>先检查 workflow 自身的 capability 集是否包含非 CPU 能力。</li></ul><ol><li>若尚未确定 IO，遍历 step 缓存，遇到 IO 即返回 <code>IO_EFFECT_TYPE</code>。</li><li>若仅检测到 CPU，则返回 <code>CPU_EFFECT_TYPE</code>，否则默认为 <code>PURE_EFFECT_TYPE</code>。</li></ol></li><li>该优化避免了对每个 step 进行二次 <code>collectEffects</code> 遍历，在大型 workflow（100+ steps）中可减少 30% 以上的类型检查时间。</li></ul><h2 id="effect-inference" tabindex="-1">Effect Inference <a class="header-anchor" href="#effect-inference" aria-label="Permalink to “Effect Inference”">​</a></h2><h3 id="effectcollector-扩展" tabindex="-1">EffectCollector 扩展 <a class="header-anchor" href="#effectcollector-扩展" aria-label="Permalink to “EffectCollector 扩展”">​</a></h3><ul><li><code>src/effect_inference.ts</code> 的 <code>EffectCollector</code> 在遍历 <code>workflow</code> 时默认添加 IO effect，并递归访问 step 主体与补偿块。</li><li>任一步骤一旦包含 workflow 语句，即强制 <code>localEffects</code> 添加 IO，确保 <code>inferEffects</code> 输出的 requiredEffects 与 Typechecker 一致。</li></ul><h3 id="capability-验证机制" tabindex="-1">Capability 验证机制 <a class="header-anchor" href="#capability-验证机制" aria-label="Permalink to “Capability 验证机制”">​</a></h3><ul><li><code>collectCapabilities</code> 遍历 <code>Core.Block</code> 中的调用，根据 <code>inferCapabilityFromName</code> 推断能力。</li><li><code>reportWorkflowCapabilityViolation</code> 比较函数头部声明的 <code>effectCaps</code> 与观察到的 capability 集： <ul><li>缺失声明 → <strong>E027(WORKFLOW_UNDECLARED_CAPABILITY)</strong>，payload 包含 <code>{ func, step, capability }</code>。</li><li>冗余声明则通过 <code>EFF_CAP_SUPERFLUOUS</code> 提示。</li></ul></li></ul><h3 id="compensate-capability-约束" tabindex="-1">Compensate capability 约束 <a class="header-anchor" href="#compensate-capability-约束" aria-label="Permalink to “Compensate capability 约束”">​</a></h3><ul><li>对于带补偿的步骤，Typechecker 再次采集补偿块的能力集合，并与主体集合比较。</li><li>若补偿新增能力，抛出 <strong>E028</strong>，提示在主体中执行相同能力或扩展函数声明。</li></ul><h2 id="runtime-集成" tabindex="-1">Runtime 集成 <a class="header-anchor" href="#runtime-集成" aria-label="Permalink to “Runtime 集成”">​</a></h2><h3 id="jvm-emitter" tabindex="-1">JVM Emitter <a class="header-anchor" href="#jvm-emitter" aria-label="Permalink to “JVM Emitter”">​</a></h3><ul><li><code>src/jvm/emitter.ts</code> 的 <code>emitWorkflowStatement</code>： <ol><li>为每个 Workflow 创建 <code>AsyncTaskRegistry</code> 与 <code>WorkflowScheduler</code>。</li><li>为每个 step 生成 <code>java.util.function.Supplier&lt;Object&gt;</code>，并在注册时附带补偿逻辑。</li><li>将 <code>Core.Step.dependsOn</code> 降级为 Java <code>Map&lt;String, Set&lt;String&gt;&gt;</code>，通过 <code>workflowDependencyLiteral</code> 传入 <code>WorkflowNode</code>。</li><li>缺省情况下（缺失显式依赖）自动填充 <code>prevStep -&gt; currentStep</code> 关系，确保旧语法仍串行执行。</li><li>Retry 信息目前以注释形式保留；timeout 仅在调用方保留毫秒值，Scheduler 直接调用 <code>executeUntilComplete()</code>。</li></ol></li></ul><h3 id="workflownode-接口" tabindex="-1">WorkflowNode 接口 <a class="header-anchor" href="#workflownode-接口" aria-label="Permalink to “WorkflowNode 接口”">​</a></h3><ul><li><code>aster-truffle/src/main/java/aster/truffle/nodes/WorkflowNode.java</code> 构成运行时入口： <ul><li>构造函数接收 <code>Env</code>, <code>Node[] taskExprs</code>, <code>String[] taskNames</code>, <code>Map&lt;String, Set&lt;String&gt;&gt; dependencies</code>, <code>timeoutMs</code>。</li><li><code>execute</code> 中为每个 step 捕获 Frame 与 effect 权限，直接调用 <code>AsyncTaskRegistry.registerTaskWithDependencies</code>，由 <code>WorkflowScheduler</code> 驱动执行并收集结果。</li></ul></li></ul><h3 id="asynctaskregistry-dependencygraph-workflowscheduler" tabindex="-1">AsyncTaskRegistry/DependencyGraph/WorkflowScheduler <a class="header-anchor" href="#asynctaskregistry-dependencygraph-workflowscheduler" aria-label="Permalink to “AsyncTaskRegistry/DependencyGraph/WorkflowScheduler”">​</a></h3><ul><li><strong>AsyncTaskRegistry</strong>： <ul><li>使用 <code>CompletableFuture</code> + <code>ExecutorService</code>（线程池大小默认等于 CPU 核心）批量并发执行就绪任务，必要时退化为单线程。</li><li><code>registerTaskWithDependencies</code> 把依赖信息写入内部 <code>DependencyGraph</code>，并维护 <code>remainingTasks</code> 计数。</li><li><code>executeUntilComplete</code> 循环提取 <code>readyQueue</code>，若无任务可调度则执行失败/死锁检测： <ul><li>存在失败任务 → 直接抛出其异常。</li><li>无失败但无就绪节点 → 抛出 <code>IllegalStateException(&quot;Deadlock detected&quot;)</code>。</li></ul></li><li>成功完成的 step 会把结果写回 <code>TaskState</code> 并推送到补偿堆栈，失败时通过 <code>CompletableFuture</code> 传播，上层再触发 LIFO 补偿。</li></ul></li><li><strong>DependencyGraph</strong>： <ul><li><code>addTask</code> 在注册阶段执行 DFS 循环检测（<code>hasCycleDFS</code>），阻止环路写入。</li><li><code>markCompleted</code> 负责递减依赖计数并把新就绪节点放入 <code>readyQueue</code>，保持声明顺序。</li></ul></li><li><strong>WorkflowScheduler</strong>：充当 AsyncTaskRegistry 的 thin wrapper，仅暴露 <code>executeUntilComplete()</code> 与少量过渡 API，用于 Start/Await 节点兼容。</li><li>Workflow emitter 与 WorkflowNode 直接注册任务至 AsyncTaskRegistry，并通过 WorkflowScheduler 一次性驱动完成；整个调度栈无需外部 DependencyGraph 或自定义线程管理。</li></ul><p>该实现路径确保从语法到 runtime 的闭环：Parser 生成带 span 的 AST，降级为携带 capability 元数据的 Core IR，Typechecker/Effect inference 负责静态验证，JVM emitter/WorkflowNode 则将抽象语义映射到 AsyncTaskRegistry + DependencyGraph + WorkflowScheduler 的执行模型。</p>',41)])])}const k=o(r,[["render",t]]);export{h as __pageData,k as default};
