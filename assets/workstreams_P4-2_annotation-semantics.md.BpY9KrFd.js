import{_ as a,c as i,o as s,aj as l}from"./chunks/framework.Bz2R-749.js";const f=JSON.parse('{"title":"P4-2 注解语义框架设计","description":"","frontmatter":{},"headers":[],"relativePath":"workstreams/P4-2/annotation-semantics.md","filePath":"workstreams/P4-2/annotation-semantics.md"}'),n={name:"workstreams/P4-2/annotation-semantics.md"};function o(t,e,c,r,d,p){return s(),i("div",null,[...e[0]||(e[0]=[l(`<h1 id="p4-2-注解语义框架设计" tabindex="-1">P4-2 注解语义框架设计 <a class="header-anchor" href="#p4-2-注解语义框架设计" aria-label="Permalink to “P4-2 注解语义框架设计”">​</a></h1><p><strong>日期</strong>：2025-11-14 06:51 NZST<br><strong>执行者</strong>：Codex</p><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">​</a></h2><ul><li><a href="#_1-pii-注解语义设计">1. PII 注解语义设计</a><ul><li><a href="#_11-设计目标与约束">1.1 设计目标与约束</a></li><li><a href="#_12-类型传播规则">1.2 类型传播规则</a></li><li><a href="#_13-赋值兼容性矩阵">1.3 赋值兼容性矩阵</a></li><li><a href="#_14-输出限制与敏感接收方">1.4 输出限制与敏感接收方</a></li><li><a href="#_15-类型检查算法伪代码">1.5 类型检查算法（伪代码）</a></li><li><a href="#_16-代码生成与元数据保留">1.6 代码生成与元数据保留</a></li><li><a href="#_17-参考资料">1.7 参考资料</a></li></ul></li><li><a href="#_2-capability-注解语义设计">2. Capability 注解语义设计</a><ul><li><a href="#_21-设计目标与命名空间">2.1 设计目标与命名空间</a></li><li><a href="#_22-效果多态与签名语法">2.2 效果多态与签名语法</a></li><li><a href="#_23-调用检查与上下文要求">2.3 调用检查与上下文要求</a></li><li><a href="#_24-manifest-验证连接">2.4 Manifest 验证连接</a></li><li><a href="#_25-java-端补齐点">2.5 Java 端补齐点</a></li><li><a href="#_26-类型检查算法伪代码">2.6 类型检查算法（伪代码）</a></li><li><a href="#_27-参考资料">2.7 参考资料</a></li></ul></li><li><a href="#_3-双栈一致性保证">3. 双栈一致性保证</a></li><li><a href="#_4-渐进式迁移路径">4. 渐进式迁移路径</a></li></ul><hr><h2 id="_1-pii-注解语义设计" tabindex="-1">1. PII 注解语义设计 <a class="header-anchor" href="#_1-pii-注解语义设计" aria-label="Permalink to “1. PII 注解语义设计”">​</a></h2><h3 id="_1-1-设计目标与约束" tabindex="-1">1.1 设计目标与约束 <a class="header-anchor" href="#_1-1-设计目标与约束" aria-label="Permalink to “1.1 设计目标与约束”">​</a></h3><ul><li><strong>绑定式类型标注</strong>：沿用 <code>TypePii</code>（<code>src/types.ts:369-378</code>）与 <code>CoreModel.Annotation</code>（<code>aster-core/.../CoreModel.java:137-146</code>）结构，将 <code>@pii(level, category)</code> 视为<strong>包裹类型</strong>而非独立语法糖。</li><li><strong>等级与类别双维度</strong>：<code>level ∈ {L1 &lt; L2 &lt; L3}</code> 表示敏感度，<code>category</code> 与 <code>PiiDataCategory</code> 枚举保持一致（邮箱/金融/健康等）。</li><li><strong>运行时可见元数据</strong>：Java ASM emitter 必须把 PII 信息写入 <code>RuntimeVisible(Type)Annotations</code>，以便策略引擎、DTO、Policy VM 重用。</li><li><strong>性能约束</strong>：类型检查阶段仅对包含 <code>TypePii</code> 的类型执行额外流分析，避免对纯净模块产生额外成本；缓存 PII lattice 判定结果。</li><li><strong>无安全退让</strong>：遵循 Phase 4 方针，禁止“允许日志但打印警告”式策略，输出限制只有“允许/拒绝/先调用脱敏 API”三态。</li></ul><h3 id="_1-2-类型传播规则" tabindex="-1">1.2 类型传播规则 <a class="header-anchor" href="#_1-2-类型传播规则" aria-label="Permalink to “1.2 类型传播规则”">​</a></h3><ol><li><strong>函数签名</strong><ul><li>参数或返回值可以写成 <code>@pii(L2, email) Text</code>。编译器在函数类型中保留 <code>piiMeta = {level, category}</code>。</li><li>泛型函数可允许 <code>T: Pii</code> 约束，将 <code>TypeVar</code> 与 <code>TypePii</code> 组合，便于 effect/PII 联动。</li></ul></li><li><strong>调用传播</strong><ul><li>如果被调函数返回 PII，调用点推断结果附带同级 <code>piiMeta</code>。若调用者立刻将结果赋给普通类型，判定为降级违规。</li><li>内建脱敏算子（例如 <code>redact(levelTarget)</code> 或 <code>aggregate()</code>）返回新的 <code>TypePii</code>，level 可以降低但必须遵守 lattice（详见 1.3）。</li></ul></li><li><strong>表达式组合</strong><ul><li>算术/字符串操作遵循“最敏感者优先”：<code>L3 ⊕ L1 → L3</code>。类别合并产生集合，供后续输出校验使用。</li><li>分支/模式匹配中，如任一分支产出 PII，则整个表达式返回合并后的 PII。</li></ul></li><li><strong>容器与高阶类型</strong><ul><li><code>List&lt;@pii(L2, financial) Money&gt;</code> 允许，但容器类型自身不自动成为 PII，只有在访问元素时传播属性。</li><li><code>Result&lt;@pii(L3, biometric) Data, E&gt;</code>：在 <code>await</code>、<code>match</code> 解构时把 PII 元数据继续附加到绑定变量。</li></ul></li></ol><h3 id="_1-3-赋值兼容性矩阵" tabindex="-1">1.3 赋值兼容性矩阵 <a class="header-anchor" href="#_1-3-赋值兼容性矩阵" aria-label="Permalink to “1.3 赋值兼容性矩阵”">​</a></h3><table tabindex="0"><thead><tr><th>左值等级</th><th>允许的右值等级</th><th>备注</th></tr></thead><tbody><tr><td><code>Plain</code>（无 PII）</td><td>仅 <code>Plain</code></td><td>任何 PII→Plain 赋值报错（<code>PII_ASSIGN_DOWNGRADE</code>）。</td></tr><tr><td><code>L1</code></td><td><code>Plain</code>（自动提升为 <code>L1</code>）、<code>L1</code></td><td><code>Plain</code> 右值会被视为 <code>L1</code> 并记录来源，方便后续追踪。</td></tr><tr><td><code>L2</code></td><td><code>L2</code>、<code>L3</code> 禁止</td><td>只能接收 <code>L2</code>，若 <code>L1</code> 赋给 <code>L2</code> 则隐式升级（并标记 <code>PII_IMPLICIT_UPLEVEL</code> warning）。</td></tr><tr><td><code>L3</code></td><td><code>L3</code></td><td>最高级别禁止任何降级。</td></tr></tbody></table><p>类别兼容性：</p><ul><li>默认要求 <strong>精确匹配</strong>（email 只能赋给 email）。</li><li>如果目标声明为 <code>category = any</code>，允许集合向下兼容，但需记录具体来源集合用于输出限制。</li><li>多类别聚合时记录集合，并阻止把集合赋给单一类别变量。</li></ul><h3 id="_1-4-输出限制与敏感接收方" tabindex="-1">1.4 输出限制与敏感接收方 <a class="header-anchor" href="#_1-4-输出限制与敏感接收方" aria-label="Permalink to “1.4 输出限制与敏感接收方”">​</a></h3><ol><li><strong>敏感 sink 定义</strong><ul><li>内建 IO：<code>print</code>, <code>log</code>, <code>http.*</code>, <code>sql.*</code>, <code>workflow step</code>、<code>emit</code> 等都标记 sink 分类（控制台、持久化、网络）。</li><li>自定义函数可通过 <code>@sink(kind = &#39;log&#39;)</code> 声明。</li></ul></li><li><strong>规则</strong><ul><li><code>level &gt;= L2</code> 数据 <strong>禁止</strong> 输出到 <code>log/print</code>。</li><li><code>L3</code> 数据只有在 <code>redact(L3 → L1)</code> 或 <code>tokenize()</code> 之后才能进入任何 sink。</li><li>输出到网络/数据库必须同时声明 <code>@io with Http/Sql</code> 并拥有 <code>Capability</code> 校验通过。</li><li>允许配置 <code>@piiAllow(level&lt;=L1, sinks=[audit])</code> 注解在函数头上，供特殊审计场景使用。</li></ul></li><li><strong>诊断</strong><ul><li>缺失脱敏：<code>PII_SINK_UNSANITIZED</code>。</li><li>缺失 capability：交给 <code>EFF_CAP_MISSING</code>（第二节）。</li><li>未声明 <code>@pii</code> 却从 sink 捕获：<code>PII_SINK_UNKNOWN</code>，提示开发者补注解以追踪。</li></ul></li></ol><h3 id="_1-5-类型检查算法-伪代码" tabindex="-1">1.5 类型检查算法（伪代码） <a class="header-anchor" href="#_1-5-类型检查算法-伪代码" aria-label="Permalink to “1.5 类型检查算法（伪代码）”">​</a></h3><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>procedure checkModulePII(module):</span></span>
<span class="line"><span>  lattice = {Plain &lt; L1 &lt; L2 &lt; L3}</span></span>
<span class="line"><span>  for each func in module.funcs:</span></span>
<span class="line"><span>    env = new Map&lt;Symbol, PiiMeta&gt;()</span></span>
<span class="line"><span>    seedEnvWithParams(func, env)</span></span>
<span class="line"><span>    traverseBlock(func.body, env)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>procedure traverseBlock(block, env):</span></span>
<span class="line"><span>  for stmt in block:</span></span>
<span class="line"><span>    match stmt.kind:</span></span>
<span class="line"><span>      case Assignment(lhs, rhs):</span></span>
<span class="line"><span>        rhsMeta = inferExprPii(rhs, env)</span></span>
<span class="line"><span>        lhsMeta = env.get(lhs) or metaFromType(lhs.type)</span></span>
<span class="line"><span>        if violatesAssignment(lhsMeta, rhsMeta):</span></span>
<span class="line"><span>          report(PII_ASSIGN_DOWNGRADE, stmt.span, details)</span></span>
<span class="line"><span>        env[lhs] = merge(lhsMeta, rhsMeta)</span></span>
<span class="line"><span>      case Call(target, args):</span></span>
<span class="line"><span>        callMeta = lookupFuncSignature(target)</span></span>
<span class="line"><span>        foreach (param, arg) in zip(callMeta.params, args):</span></span>
<span class="line"><span>          argMeta = inferExprPii(arg, env)</span></span>
<span class="line"><span>          if violatesAssignment(param.meta, argMeta):</span></span>
<span class="line"><span>            report(PII_ARG_VIOLATION, arg.span, details)</span></span>
<span class="line"><span>        if callMeta.returnMeta:</span></span>
<span class="line"><span>          return annotate(callMeta.returnMeta)</span></span>
<span class="line"><span>      case Sink(kind, value):</span></span>
<span class="line"><span>        meta = inferExprPii(value, env)</span></span>
<span class="line"><span>        if not allowed(kind, meta):</span></span>
<span class="line"><span>          report(PII_SINK_UNSANITIZED, stmt.span, {kind, meta})</span></span>
<span class="line"><span>      case Block/Nested:</span></span>
<span class="line"><span>        traverseBlock(stmt.body, env.clone())</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function inferExprPii(expr, env):</span></span>
<span class="line"><span>  match expr.kind:</span></span>
<span class="line"><span>    case Literal: return Plain</span></span>
<span class="line"><span>    case Var(name): return env.get(name) or metaFromType(expr.type)</span></span>
<span class="line"><span>    case Binary(lhs, rhs):</span></span>
<span class="line"><span>      return merge(inferExprPii(lhs), inferExprPii(rhs))</span></span>
<span class="line"><span>    case Call(...):</span></span>
<span class="line"><span>      // handled在 Call 节点</span></span></code></pre></div><p>算法实现细节：</p><ul><li>TypeScript 与 Java 共用 <code>pii_meta.ts</code> / <code>PiiMeta.java</code> 工具模块，包含 lattice 判断与 merge 函数，确保性能一致。</li><li><code>merge</code> 产生 <code>(maxLevel, unionCategories)</code> 并缓存结果以避免重复计算。</li><li><code>inferExprPii</code> 返回 <code>Plain</code>（无 PII）或 <code>{level, categories, sourceSpan}</code>。</li></ul><h3 id="_1-6-代码生成与元数据保留" tabindex="-1">1.6 代码生成与元数据保留 <a class="header-anchor" href="#_1-6-代码生成与元数据保留" aria-label="Permalink to “1.6 代码生成与元数据保留”">​</a></h3><ol><li><strong>Core IR</strong><ul><li><code>TypePii</code> 在 CoreLowering 阶段转换为 <code>Core.TypeName</code> + <code>CoreModel.Annotation{name=&#39;pii&#39;, params={level, category}}</code>。</li><li>函数/字段上的注解放入 <code>Core.Func.annotations</code>、<code>Core.Param.annotations</code>。</li></ul></li><li><strong>TypeScript Emitter</strong><ul><li><code>core-ir/serialize.ts</code> 将 <code>Annotation</code> 序列化到 JSON，CLI/LSP 共享。</li><li>CLI 在生成 DTO/Manifest 时保留 <code>piiMeta</code> 供 CLI/LSP 输出。</li></ul></li><li><strong>Java TypeChecker → ASM</strong><ul><li><code>aster-core</code> TypeChecker 读取 <code>Annotation</code> 并生成 <code>PiiMeta</code> 对象，与 TypeScript 共享 lattice。</li><li><code>aster-asm-emitter</code> 增加 <code>addPiiAnnotation(MethodVisitor mv, PiiMeta meta)</code>，写入 <code>@AsterPii(level=\\&quot;L2\\&quot;, category={\\&quot;email\\&quot;})</code>（<code>Retention=CLASS</code>）。</li><li><code>quarkus-policy-api</code>、Policy VM 可经由反射/ASM Reads 还原 PII metadata，实现运行时拦截。</li></ul></li></ol><h3 id="_1-7-参考资料" tabindex="-1">1.7 参考资料 <a class="header-anchor" href="#_1-7-参考资料" aria-label="Permalink to “1.7 参考资料”">​</a></h3><ul><li>Harpocrates 对“把隐私策略绑定到类型”的做法提供了 PII 随数据传播的范式，适用于我们在函数签名层保留 level/category（<a href="https://arxiv.org/abs/2411.06317" target="_blank" rel="noreferrer">Harpocrates, 2024</a>）。</li><li>“A Type System for Data Privacy Compliance” 强调静态合规检查需要在语言层提供等级推理，印证我们采用的 lattice 与 sink 校验（<a href="https://arxiv.org/abs/2508.03831" target="_blank" rel="noreferrer">Baramashetru et al., 2025</a>）。</li><li>“Practical Type-Based Taint Checking and Inference” 证明类型化污点分析可模块化且高性能，是本方案中 <code>inferExprPii</code>/<code>merge</code> 设计的依据（<a href="https://drops.dagstuhl.de/storage/00lipics/lipics..." target="_blank" rel="noreferrer">Karimipour et al., 2023</a>)。</li><li>Cocoon、Duet 等隐私语言实践强调“最敏感者优先”和“不可静默降级”，对应我们在 1.2/1.3 的合并与赋值策略（<a href="https://arxiv.org/abs/2311.00097" target="_blank" rel="noreferrer">Cocoon, 2024</a>，<a href="https://arxiv.org/pdf/1909.02481" target="_blank" rel="noreferrer">Duet, 2019</a>）。</li></ul><hr><h2 id="_2-capability-注解语义设计" tabindex="-1">2. Capability 注解语义设计 <a class="header-anchor" href="#_2-capability-注解语义设计" aria-label="Permalink to “2. Capability 注解语义设计”">​</a></h2><h3 id="_2-1-设计目标与命名空间" tabindex="-1">2.1 设计目标与命名空间 <a class="header-anchor" href="#_2-1-设计目标与命名空间" aria-label="Permalink to “2.1 设计目标与命名空间”">​</a></h3><ul><li>统一 <code>@io</code>, <code>@async</code>, <code>@sql</code>, <code>@http</code>, <code>@secrets</code> 等能力到 <code>CapabilityKind</code> 列表，由 <code>Core.Func</code> 的 <code>effectCaps</code>/<code>effectCapsExplicit</code> 承载（<code>src/typecheck.ts:420-455</code> 已有 TS 端逻辑）。</li><li>区分“<strong>效果</strong>”与“<strong>能力</strong>”： <ul><li>效果（effect）描述全局副作用类别（IO、CPU、Async）。</li><li>能力（capability）描述访问特定资源的权限（Http、Sql、KV、Secrets）。</li><li><code>@io</code> 是效果，<code>@io with Http,Sql</code> 将能力挂载到 <code>io</code> 效果之上。</li></ul></li><li>命名空间：<code>@capability::&lt;Resource&gt;</code> 约定用于未来扩展（如 <code>@capability::Storage(S3)</code>）。</li></ul><h3 id="_2-2-效果多态与签名语法" tabindex="-1">2.2 效果多态与签名语法 <a class="header-anchor" href="#_2-2-效果多态与签名语法" aria-label="Permalink to “2.2 效果多态与签名语法”">​</a></h3><ul><li><strong>语法</strong>：<code>It performs {effectRow} [with CapabilityList]</code>。例如<br><code>It performs io, async with Http, Secrets</code>。</li><li><strong>效果多态</strong>：支持 <code>It performs {E}</code>，其中 <code>E</code> 为 effect row 变量，调用点通过 <code>where</code> 约束实例化：<br><code>fn run&lt;E&gt;(task: () -&gt; E T) performs E</code>。TypeChecker 需将 <code>E</code> 展开为调用实参的 effect 集。</li><li><strong>组合规则</strong>： <ul><li>Effect row 使用集合语义，并保持顺序用于诊断输出。</li><li>Default：无声明时默认为 <code>CPU</code>，禁止隐式 IO。</li><li><code>async</code> 效果隐含 <code>cpu</code>，与 <code>io</code> 并列。</li></ul></li></ul><h3 id="_2-3-调用检查与上下文要求" tabindex="-1">2.3 调用检查与上下文要求 <a class="header-anchor" href="#_2-3-调用检查与上下文要求" aria-label="Permalink to “2.3 调用检查与上下文要求”">​</a></h3><ol><li><strong>调用侧</strong><ul><li>调用者 effect row 必须是被调者 effect row 的<strong>超集</strong>。</li><li>对于 capability，调用者 <code>CapabilitySet</code> 必须覆盖被调者 <code>uses</code> 集合（含 workflow step 合并）。</li></ul></li><li><strong>闭包/高阶函数</strong><ul><li>捕获效果随闭包类型传播：<code>() -&gt; @io Http</code> 等同于函数类型上附带 effect row。</li></ul></li><li><strong>Workflow 特例</strong><ul><li><code>workflow</code> block 自动注入 <code>io</code> 效果。</li><li>Step/compensate 体的 capability 归并到函数头（延续 <code>checkEffects</code> 中的 <code>collectWorkflows</code> 逻辑）。</li></ul></li><li><strong>诊断</strong><ul><li>缺失 effect：<code>EFF_MISSING_IO</code>, <code>EFF_MISSING_CPU</code>（已存在）。</li><li>缺失 capability：<code>EFF_CAP_MISSING</code>。</li><li>多余 capability：保留 info 级别，指导开发者缩减权限。</li></ul></li></ol><h3 id="_2-4-manifest-验证连接" tabindex="-1">2.4 Manifest 验证连接 <a class="header-anchor" href="#_2-4-manifest-验证连接" aria-label="Permalink to “2.4 Manifest 验证连接”">​</a></h3><ul><li>TypeScript 现有 <code>typecheckModuleWithCapabilities</code> 通过 manifest（YAML/JSON）声明可用能力。</li><li>新语义要求： <ol><li>Manifest 声明 -&gt; 模块默认 Capability 集合。</li><li>函数声明 -&gt; 对 manifest 集合求子集。</li><li><code>src/typecheck.ts</code> 中的 <code>checkCapabilities</code> 扩展为：当函数声明了 capability 但 manifest 未授权时，报 <code>WORKFLOW_UNDECLARED_CAPABILITY</code>。</li></ol></li><li>Manifest 解析层向 Java 侧输出同构 JSON，Java TypeChecker 读取后执行同样的集合判断。</li></ul><h3 id="_2-5-java-端补齐点" tabindex="-1">2.5 Java 端补齐点 <a class="header-anchor" href="#_2-5-java-端补齐点" aria-label="Permalink to “2.5 Java 端补齐点”">​</a></h3><ul><li><code>aster-core/src/main/java/aster/core/typecheck/TypeChecker.java</code> 需新增 <code>CapabilityAnalyzer</code>： <ul><li>扫描 <code>Core.Func.effectCaps/effectCapsExplicit</code>。</li><li>调用 <code>CapabilityCollector</code> 分析 <code>Core.Expr</code>，与 TypeScript <code>collectCapabilities</code> 行为一致。</li><li>复用 <code>shared/error_codes.json</code> 的 <code>E027/E028/EFF_CAP_*</code> 以保持诊断一致。</li></ul></li><li><code>aster-asm-emitter</code> 将函数效果写入 <code>@AsterEffects(effects=[&quot;io&quot;,&quot;async&quot;], capabilities=[&quot;Http&quot;])</code>，供运行时审查/策略引擎读取。</li></ul><h3 id="_2-6-类型检查算法-伪代码" tabindex="-1">2.6 类型检查算法（伪代码） <a class="header-anchor" href="#_2-6-类型检查算法-伪代码" aria-label="Permalink to “2.6 类型检查算法（伪代码）”">​</a></h3><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>procedure checkModuleCapabilities(module, manifestCaps):</span></span>
<span class="line"><span>  for func in module.funcs:</span></span>
<span class="line"><span>    declaredEff = normalizeEffectRow(func.effects)</span></span>
<span class="line"><span>    declaredCaps = new Set(func.effectCaps)</span></span>
<span class="line"><span>    usedCaps = collectCapabilities(func.body)</span></span>
<span class="line"><span>    usedEff = collectEffects(func.body)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if not declaredEff.superset(usedEff):</span></span>
<span class="line"><span>      report(EFF_MISSING_xxx)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    missingCaps = usedCaps - declaredCaps</span></span>
<span class="line"><span>    if missingCaps not empty:</span></span>
<span class="line"><span>      report(EFF_CAP_MISSING, func.span, {missingCaps})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    superfluousCaps = declaredCaps - usedCaps</span></span>
<span class="line"><span>    if superfluousCaps not empty:</span></span>
<span class="line"><span>      report(EFF_CAP_SUPERFLUOUS, func.span, {superfluousCaps})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if not manifestCaps.containsAll(declaredCaps):</span></span>
<span class="line"><span>      report(WORKFLOW_UNDECLARED_CAPABILITY, func.span, details)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if func.workflowSteps:</span></span>
<span class="line"><span>      checkWorkflowSteps(func, declaredCaps)</span></span></code></pre></div><p>辅助函数：</p><ul><li><code>collectCapabilities</code>：遍历 AST，识别内建 IO、workflow step、外部调用的 <code>CapabilityKind</code>。与 TypeScript 实现共享一套“调用→capability”映射表。</li><li><code>normalizeEffectRow</code>：在 TS/Java 共享的 <code>EffectRow</code> 模块中实现排序与去重，并缓存以降低比对成本。</li><li><code>checkWorkflowSteps</code>：针对 step/compensate 体执行二次分析，沿用 TS 中的 <code>reportWorkflowCapabilityViolation</code> 语义。</li></ul><h3 id="_2-7-参考资料" tabindex="-1">2.7 参考资料 <a class="header-anchor" href="#_2-7-参考资料" aria-label="Permalink to “2.7 参考资料”">​</a></h3><ul><li>“Effect system” 条目与 Xavier Leroy 的《Type and Effect Systems》章节提供了 effect row/subtyping 的理论基础，我们据此实现 effect 超集判定与 row 多态（<a href="https://en.wikipedia.org/wiki/Effect_system" target="_blank" rel="noreferrer">Effect system, 2025</a>；<a href="http://xavierleroy.org/control-structures/book/main015.html" target="_blank" rel="noreferrer">Leroy, 2017</a>）。</li><li>Austral 语言的 capability 设计展示了“函数签名显式声明所需权限”的工程实践，验证了我们在函数头声明能力的必要性（<a href="https://borretti.me/article/how-capabilities-work" target="_blank" rel="noreferrer">Austral Capabilities, 2023</a>).</li><li>CMU 比较研究强调 capability 模块系统在落地时需配套 manifest/最小权限策略，支撑我们在 2.4 的 manifest 对齐要求（<a href="https://kilthub.cmu.edu/articles/conference_contribution/" target="_blank" rel="noreferrer">Goyal et al., 2024</a>).</li><li>Capability-based security 总结了“能力是不可伪造的引用”，提醒我们在 IR/字节码阶段必须以注解形式保留证据（<a href="https://en.wikipedia.org/wiki/Capability-based_security" target="_blank" rel="noreferrer">Wikipedia, 2025</a>）。</li></ul><hr><h2 id="_3-双栈一致性保证" tabindex="-1">3. 双栈一致性保证 <a class="header-anchor" href="#_3-双栈一致性保证" aria-label="Permalink to “3. 双栈一致性保证”">​</a></h2><ul><li><strong>统一错误码</strong>：所有新增诊断（<code>PII_ASSIGN_DOWNGRADE</code>, <code>PII_SINK_UNSANITIZED</code>, <code>PII_ARG_VIOLATION</code> 等）必须先写入 <code>shared/error_codes.json</code>，并同步生成 TypeScript <code>ErrorCode</code> 枚举与 Java <code>ErrorCode</code> enum。</li><li><strong>诊断结构对齐</strong>：延续 <code>.claude/context-question-1.json</code> 中对诊断格式的分析，将 PII/Capability 检查产出的 <code>data</code> 字段约定为 <code>{level, categories, sinkKind, capability}</code>，两侧 JSON 完全一致。</li><li><strong>Cross-stack 测试</strong>：扩展 <code>scripts/cross_validate.sh</code>，在 AST diff 之后追加 <code>diagnostics/pii/*.json</code> 对比；当 TypeScript/Java 结果不一致时输出 diff 并阻塞 CI。</li><li><strong>共享分析库</strong>：在 <code>packages/shared/</code> 新增 <code>pii-meta.ts</code>（编译出 <code>.d.ts</code> + <code>.js</code>）与 Java 对应的 <code>PiiMeta.java</code>，通过 wasm/JSON 表驱动保持 lattice、sink 配置一致。Capability 侧同理抽离 <code>EffectRow</code>、<code>CapabilitySet</code>。</li><li><strong>回归样例</strong>：<code>test/type-checker/golden/pii_*</code> <code>capability_*</code> 目录下每个案例运行 <code>tsc typecheck</code> 与 <code>java TypeCheckerCli</code>，产出的诊断 JSON 存储到 <code>test/type-checker/golden/&lt;name&gt;.ts.json</code> / <code>.java.json</code>，供 cross-validate diff。</li></ul><hr><h2 id="_4-渐进式迁移路径" tabindex="-1">4. 渐进式迁移路径 <a class="header-anchor" href="#_4-渐进式迁移路径" aria-label="Permalink to “4. 渐进式迁移路径”">​</a></h2><ol><li><strong>阶段 0（观察期）</strong><ul><li>TypeChecker 默认 <strong>记录但不阻断</strong>：新增 <code>--enforce-pii</code> 与 <code>ENFORCE_CAPABILITIES</code> 开关默认关闭，仅输出 warning。</li><li>CLI 增加 <code>--pii-report</code> 生成 <code>pii-usage.json</code>，供团队评估已有代码中注解覆盖率。</li></ul></li><li><strong>阶段 1（新代码强制）</strong><ul><li>在 <code>.shrimp/tasks.json</code> 中为新模块标记 <code>requirePiiAnnotations = true</code>。</li><li>TypeChecker 对新模块启用强制模式（按 manifest）。旧模块仍允许 warning。</li></ul></li><li><strong>阶段 2（全局启用）</strong><ul><li>打开 <code>--enforce-pii</code> / <code>ENFORCE_CAPABILITIES</code>，所有模块必须满足规则。</li><li>结合 cross-stack diff，确保 TS/Java 诊断完全一致后方可发布。</li></ul></li><li><strong>阶段 3（运行时审计）</strong><ul><li>ASM emitter 将注解写入字节码后，Policy VM/Quarkus 服务读取并阻断运行时违规调用。</li><li>CLI/LSP 提供“跳转到 PII 来源”“列出能力使用树”等调试能力。</li></ul></li></ol><p><strong>向后兼容性</strong></p><ul><li>AST/IR 不做破坏性更改：<code>TypePii</code>/<code>Annotation</code> 已存在，只是被 TypeChecker 跳过。</li><li>通过 feature flag 控制 enforcement，允许逐文件 opt-in。</li><li>性能：PII &amp; capability 检查都在单次 AST 遍历中完成（合并 <code>collectEffects</code>、<code>collectCapabilities</code>），并缓存 lattice 结果，保证编译时间增长 &lt;10%。</li></ul><p><strong>分阶段实施计划（概述）</strong></p><ol><li><strong>W1</strong>：补齐 TypeScript TypeChecker（PII 流、sink 判定、错误码）+ golden case。</li><li><strong>W2</strong>：Java TypeChecker 同步实现 + cross-stack diff pipeline。</li><li><strong>W3</strong>：ASM emitter/DTO 输出 PII/Effect 注解 + runtime 消费示例。</li><li><strong>W4</strong>：启用 feature flag、更新 manifest、在 docs/testing.md 记录新测试命令。</li><li><strong>W5</strong>：将 cross-stack 验证接入 CI，并启动阶段 1 强制。</li></ol><hr>`,53)])])}const g=a(n,[["render",o]]);export{f as __pageData,g as default};
