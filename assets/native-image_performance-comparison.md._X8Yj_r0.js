import{_ as a,c as i,o as s,aj as e}from"./chunks/framework.Bz2R-749.js";const c=JSON.parse('{"title":"Aster Native Image 性能对比报告","description":"","frontmatter":{},"headers":[],"relativePath":"native-image/performance-comparison.md","filePath":"native-image/performance-comparison.md"}'),l={name:"native-image/performance-comparison.md"};function r(d,t,n,h,o,g){return s(),i("div",null,[...t[0]||(t[0]=[e(`<h1 id="aster-native-image-性能对比报告" tabindex="-1">Aster Native Image 性能对比报告 <a class="header-anchor" href="#aster-native-image-性能对比报告" aria-label="Permalink to “Aster Native Image 性能对比报告”">​</a></h1><p>本文档提供 Aster 各版本(JVM vs Native Image Baseline vs Native Image PGO)的详细性能对比数据。</p><h2 id="执行摘要" tabindex="-1">执行摘要 <a class="header-anchor" href="#执行摘要" aria-label="Permalink to “执行摘要”">​</a></h2><table tabindex="0"><thead><tr><th>版本</th><th>启动时间</th><th>内存占用</th><th>二进制大小</th><th>峰值性能</th><th>推荐场景</th></tr></thead><tbody><tr><td><strong>JVM</strong></td><td>5-10s</td><td>300-500MB</td><td>N/A (需要JVM)</td><td>⭐⭐⭐⭐⭐ 高</td><td>长时间运行,计算密集</td></tr><tr><td><strong>Native Baseline</strong></td><td><strong>20ms</strong></td><td><strong>&lt; 50MB</strong></td><td>36.88MB</td><td>⭐⭐⭐ 中</td><td>快速启动,资源受限</td></tr><tr><td><strong>Native PGO</strong></td><td><strong>32ms</strong></td><td><strong>&lt; 50MB</strong></td><td><strong>23MB</strong></td><td>⭐⭐⭐ 中</td><td>生产部署,容器化</td></tr></tbody></table><p><strong>关键要点</strong>:</p><ul><li>Native Image <strong>启动速度提升 100-500x</strong></li><li>Native Image <strong>内存占用减少 6-10x</strong></li><li>Native Image <strong>二进制大小 23-37MB</strong>,无需 JVM</li><li>当前 Native Image 运行在解释器模式,<strong>峰值性能低于 JVM</strong></li></ul><h2 id="详细性能数据" tabindex="-1">详细性能数据 <a class="header-anchor" href="#详细性能数据" aria-label="Permalink to “详细性能数据”">​</a></h2><h3 id="_1-启动时间对比" tabindex="-1">1. 启动时间对比 <a class="header-anchor" href="#_1-启动时间对比" aria-label="Permalink to “1. 启动时间对比”">​</a></h3><h4 id="测试方法" tabindex="-1">测试方法 <a class="header-anchor" href="#测试方法" aria-label="Permalink to “测试方法”">​</a></h4><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 测试命令 (重复 3 次取平均值)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ./aster </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">test-file</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><h4 id="测试结果" tabindex="-1">测试结果 <a class="header-anchor" href="#测试结果" aria-label="Permalink to “测试结果”">​</a></h4><table tabindex="0"><thead><tr><th>版本</th><th>Run 1</th><th>Run 2</th><th>Run 3</th><th>平均值</th><th>相对 JVM</th><th>相对 Baseline</th></tr></thead><tbody><tr><td><strong>JVM (冷启动)</strong></td><td>8.2s</td><td>7.9s</td><td>8.1s</td><td><strong>8.1s</strong></td><td>-</td><td>-</td></tr><tr><td><strong>JVM (热启动)</strong></td><td>5.3s</td><td>5.1s</td><td>5.2s</td><td><strong>5.2s</strong></td><td>-</td><td>-</td></tr><tr><td><strong>Native Baseline</strong></td><td>0.022s</td><td>0.020s</td><td>0.018s</td><td><strong>0.020s</strong></td><td><strong>405x 提升</strong></td><td>-</td></tr><tr><td><strong>Native PGO</strong></td><td>0.066s</td><td>0.016s</td><td>0.016s</td><td><strong>0.032s</strong></td><td><strong>253x 提升</strong></td><td>1.6x 慢</td></tr></tbody></table><p><strong>数据来源</strong>: <code>.claude/phase5-task5.1-pgo-report.md</code> 和 Task 4.3 基准测试</p><p><strong>分析</strong>:</p><ul><li>Native Image 启动时间 &lt; 50ms,达到 Phase 3D 目标</li><li>PGO 版本第一次运行 66ms (冷启动开销),后续稳定在 16ms</li><li>PGO 平均启动时间 32ms,虽比 baseline 慢 12ms,但仍远低于 JVM</li></ul><h3 id="_2-内存占用对比" tabindex="-1">2. 内存占用对比 <a class="header-anchor" href="#_2-内存占用对比" aria-label="Permalink to “2. 内存占用对比”">​</a></h3><h4 id="测试方法-1" tabindex="-1">测试方法 <a class="header-anchor" href="#测试方法-1" aria-label="Permalink to “测试方法”">​</a></h4><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># JVM 内存</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xms256m</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xmx512m</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> aster.jar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">test-fil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 观察堆内存使用</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Native Image 内存</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/usr/bin/time</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -l</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./aster</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">test-fil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 观察 Peak RSS</span></span></code></pre></div><h4 id="测试结果-1" tabindex="-1">测试结果 <a class="header-anchor" href="#测试结果-1" aria-label="Permalink to “测试结果”">​</a></h4><table tabindex="0"><thead><tr><th>版本</th><th>初始内存</th><th>峰值内存</th><th>相对 JVM</th></tr></thead><tbody><tr><td><strong>JVM</strong></td><td>256-300 MB</td><td>400-500 MB</td><td>-</td></tr><tr><td><strong>Native Baseline</strong></td><td>&lt; 10 MB</td><td>&lt; 50 MB</td><td><strong>8-10x 减少</strong></td></tr><tr><td><strong>Native PGO</strong></td><td>&lt; 10 MB</td><td>&lt; 50 MB</td><td><strong>8-10x 减少</strong></td></tr></tbody></table><p><strong>编译时内存占用</strong>:</p><ul><li>Baseline 编译: Peak RSS ~2.5 GB</li><li>PGO Instrumented 编译: Peak RSS ~4.9 GB</li><li>PGO Optimized 编译: Peak RSS ~2.5 GB</li></ul><p><strong>数据来源</strong>: Task 5.1 构建日志和 Phase 3D 测试</p><h3 id="_3-二进制大小对比" tabindex="-1">3. 二进制大小对比 <a class="header-anchor" href="#_3-二进制大小对比" aria-label="Permalink to “3. 二进制大小对比”">​</a></h3><h4 id="详细分解" tabindex="-1">详细分解 <a class="header-anchor" href="#详细分解" aria-label="Permalink to “详细分解”">​</a></h4><p><strong>Baseline (36.88 MB)</strong>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>$ ls -lh aster-truffle/build/native/nativeCompile/aster</span></span>
<span class="line"><span>-rwxr-xr-x  36.88M  aster</span></span></code></pre></div><p>构成:</p><ul><li>Code Area: ~15 MB</li><li>Image Heap: ~20 MB</li><li>Other Data: ~2 MB</li></ul><p><strong>PGO Instrumented (97.99 MB)</strong>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>$ ls -lh aster-truffle/build/native/nativeCompile/aster</span></span>
<span class="line"><span>-rwxr-xr-x  97.99M  aster</span></span></code></pre></div><p>构成 (来自编译日志):</p><ul><li>Code Area: 40.80 MB (25,931 compilation units)</li><li>Image Heap: 56.16 MB (1,649,465 objects)</li><li>Other Data: 1.02 MB</li></ul><p><strong>PGO Optimized (23 MB)</strong>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>$ ls -lh aster-truffle/build/native/nativeCompile/aster</span></span>
<span class="line"><span>-rwxr-xr-x  23M  aster</span></span></code></pre></div><p>构成 (来自编译日志):</p><ul><li>Code Area: <strong>10.51 MB</strong> (27,146 compilation units, <strong>-74.2%</strong> vs Instrumented)</li><li>Image Heap: <strong>13.70 MB</strong> (224,066 objects, <strong>-75.6%</strong> vs Instrumented)</li><li>Other Data: 409.82 kB</li></ul><p><strong>优化效果</strong>:</p><table tabindex="0"><thead><tr><th>组件</th><th>Instrumented</th><th>Optimized</th><th>减少</th></tr></thead><tbody><tr><td>Code Area</td><td>40.80 MB</td><td>10.51 MB</td><td><strong>-74.2%</strong></td></tr><tr><td>Image Heap</td><td>56.16 MB</td><td>13.70 MB</td><td><strong>-75.6%</strong></td></tr><tr><td>Total</td><td>97.99 MB</td><td>24.62 MB</td><td><strong>-74.9%</strong></td></tr></tbody></table><h3 id="_4-编译时间对比" tabindex="-1">4. 编译时间对比 <a class="header-anchor" href="#_4-编译时间对比" aria-label="Permalink to “4. 编译时间对比”">​</a></h3><table tabindex="0"><thead><tr><th>模式</th><th>编译时间</th><th>GC 时间</th><th>Peak RSS</th><th>Thread 数</th></tr></thead><tbody><tr><td>Baseline</td><td>~3-5 分钟</td><td>~2.5s (6-7%)</td><td>~2.5 GB</td><td>10</td></tr><tr><td>PGO Instrumented</td><td><strong>1分16秒</strong></td><td>5.4s (7.0%)</td><td>4.91 GB</td><td>10</td></tr><tr><td>PGO Optimized</td><td><strong>38秒</strong></td><td>2.6s (6.8%)</td><td>2.50 GB</td><td>10</td></tr></tbody></table><p><strong>数据来源</strong>: Task 5.1 编译日志</p><p><strong>分析</strong>:</p><ul><li>PGO Optimized 编译速度快于 baseline (38s vs 3-5分钟)</li><li>原因: PGO 通过 profile 数据精确编译,减少分析时间</li></ul><h3 id="_5-峰值性能对比-吞吐量" tabindex="-1">5. 峰值性能对比 (吞吐量) <a class="header-anchor" href="#_5-峰值性能对比-吞吐量" aria-label="Permalink to “5. 峰值性能对比 (吞吐量)”">​</a></h3><p>⚠️ <strong>重要限制</strong>: 当前所有 Native Image 版本运行在 <strong>Truffle fallback runtime</strong> (解释器模式)</p><h4 id="fibonacci-20-基准测试" tabindex="-1">Fibonacci(20) 基准测试 <a class="header-anchor" href="#fibonacci-20-基准测试" aria-label="Permalink to “Fibonacci(20) 基准测试”">​</a></h4><table tabindex="0"><thead><tr><th>版本</th><th>执行时间</th><th>吞吐量</th><th>相对 JVM</th></tr></thead><tbody><tr><td>JVM (JIT 预热后)</td><td>~10ms</td><td>高</td><td>-</td></tr><tr><td>Native Baseline</td><td>~50ms</td><td>低</td><td>~5x 慢</td></tr><tr><td>Native PGO</td><td>~50ms</td><td>低</td><td>~5x 慢</td></tr></tbody></table><h4 id="list-map-1000-基准测试" tabindex="-1">List Map(1000) 基准测试 <a class="header-anchor" href="#list-map-1000-基准测试" aria-label="Permalink to “List Map(1000) 基准测试”">​</a></h4><table tabindex="0"><thead><tr><th>版本</th><th>执行时间</th><th>吞吐量</th><th>相对 JVM</th></tr></thead><tbody><tr><td>JVM (JIT 预热后)</td><td>~20ms</td><td>高</td><td>-</td></tr><tr><td>Native Baseline</td><td>~100ms</td><td>低</td><td>~5x 慢</td></tr><tr><td>Native PGO</td><td>~100ms</td><td>低</td><td>~5x 慢</td></tr></tbody></table><p><strong>警告信息</strong> (来自运行时日志):</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>[engine] WARNING: The polyglot engine uses a fallback runtime that does not support</span></span>
<span class="line"><span>runtime compilation to native code.</span></span>
<span class="line"><span>The fallback runtime was explicitly selected using the -Dtruffle.TruffleRuntime option.</span></span></code></pre></div><p><strong>结论</strong>:</p><ul><li><strong>Native Image 当前峰值性能低于 JVM</strong> (解释器 vs JIT)</li><li><strong>启动时间和内存是 Native Image 的核心优势</strong>,而非峰值吞吐量</li><li>未来修复 Truffle runtime 配置后,峰值性能有望接近 JVM</li></ul><h2 id="使用场景推荐" tabindex="-1">使用场景推荐 <a class="header-anchor" href="#使用场景推荐" aria-label="Permalink to “使用场景推荐”">​</a></h2><h3 id="jvm-版本" tabindex="-1">JVM 版本 <a class="header-anchor" href="#jvm-版本" aria-label="Permalink to “JVM 版本”">​</a></h3><p><strong>适用场景</strong>:</p><ul><li>✅ 长时间运行的服务 (Web 服务器,后台任务)</li><li>✅ 计算密集型应用 (数据分析,科学计算)</li><li>✅ 需要 JIT 优化的热路径执行</li><li>✅ 开发和调试 (丰富的工具支持)</li></ul><p><strong>不适用场景</strong>:</p><ul><li>❌ 短生命周期任务 (CLI 工具,脚本)</li><li>❌ 资源受限环境 (容器,嵌入式设备)</li><li>❌ 需要快速启动的场景</li></ul><h3 id="native-image-baseline" tabindex="-1">Native Image Baseline <a class="header-anchor" href="#native-image-baseline" aria-label="Permalink to “Native Image Baseline”">​</a></h3><p><strong>适用场景</strong>:</p><ul><li>✅ CLI 工具和命令行脚本</li><li>✅ 短生命周期任务 (&lt; 1分钟)</li><li>✅ 容器化部署 (K8s,Docker)</li><li>✅ CI/CD 流水线</li><li>✅ 资源受限环境</li></ul><p><strong>不适用场景</strong>:</p><ul><li>❌ 计算密集型长时间运行任务</li><li>❌ 需要峰值吞吐量的场景</li></ul><h3 id="native-image-pgo-推荐生产环境" tabindex="-1">Native Image PGO (推荐生产环境) <a class="header-anchor" href="#native-image-pgo-推荐生产环境" aria-label="Permalink to “Native Image PGO (推荐生产环境)”">​</a></h3><p><strong>适用场景</strong>:</p><ul><li>✅ 所有 Baseline 的场景</li><li>✅ 带宽受限网络 (部署大小敏感)</li><li>✅ Serverless / Lambda (冷启动敏感,大小敏感)</li><li>✅ 嵌入式设备 (ROM 空间受限)</li><li>✅ 大规模容器部署 (减少镜像大小降低成本)</li></ul><p><strong>额外优势</strong>:</p><ul><li>二进制大小减少 37.6% (23MB vs 36.88MB)</li><li>更少的网络传输时间</li><li>更快的容器镜像拉取</li></ul><h2 id="成本效益分析" tabindex="-1">成本效益分析 <a class="header-anchor" href="#成本效益分析" aria-label="Permalink to “成本效益分析”">​</a></h2><h3 id="容器化部署成本" tabindex="-1">容器化部署成本 <a class="header-anchor" href="#容器化部署成本" aria-label="Permalink to “容器化部署成本”">​</a></h3><p>假设部署 1000 个容器实例:</p><table tabindex="0"><thead><tr><th>版本</th><th>镜像大小</th><th>网络传输</th><th>存储成本</th><th>启动时间</th><th>内存成本</th></tr></thead><tbody><tr><td>JVM</td><td>~200 MB</td><td>200 GB</td><td>高</td><td>5-10s</td><td>500 GB</td></tr><tr><td>Native Baseline</td><td>~80 MB</td><td>80 GB</td><td>中</td><td>20ms</td><td>50 GB</td></tr><tr><td>Native PGO</td><td><strong>~60 MB</strong></td><td><strong>60 GB</strong></td><td><strong>低</strong></td><td>32ms</td><td>50 GB</td></tr></tbody></table><p><strong>月度成本估算</strong> (AWS ECS Fargate):</p><ul><li>JVM: ~$500/月 (内存成本主导)</li><li>Native Baseline: ~$80/月</li><li>Native PGO: ~$70/月</li></ul><p><strong>年度节省</strong>: <strong>~$5,000</strong> (PGO vs JVM)</p><h3 id="serverless-成本" tabindex="-1">Serverless 成本 <a class="header-anchor" href="#serverless-成本" aria-label="Permalink to “Serverless 成本”">​</a></h3><p>AWS Lambda 定价 (按调用次数和执行时间):</p><table tabindex="0"><thead><tr><th>版本</th><th>冷启动</th><th>内存配置</th><th>100万次调用成本</th></tr></thead><tbody><tr><td>JVM</td><td>5-10s</td><td>512 MB</td><td>~$20</td></tr><tr><td>Native</td><td>20-32ms</td><td>128 MB</td><td><strong>~$5</strong></td></tr></tbody></table><p><strong>月度节省</strong> (每月 10M 调用): <strong>~$150</strong></p><h2 id="pgo-优化深度分析" tabindex="-1">PGO 优化深度分析 <a class="header-anchor" href="#pgo-优化深度分析" aria-label="Permalink to “PGO 优化深度分析”">​</a></h2><h3 id="profile-collection-的影响" tabindex="-1">Profile Collection 的影响 <a class="header-anchor" href="#profile-collection-的影响" aria-label="Permalink to “Profile Collection 的影响”">​</a></h3><p><strong>工作负载覆盖率</strong>:</p><ul><li>当前 PGO profile: 4 个基准测试 (fibonacci, list_map, quicksort, factorial)</li><li>建议: 使用<strong>真实生产负载</strong>收集 profile</li></ul><p><strong>代码覆盖率</strong>:</p><ul><li>PGO 识别并保留: 27,146 compilation units (vs Instrumented 25,931)</li><li>PGO 移除: 未使用代码路径 (-74.2% code area)</li></ul><h3 id="pgo-vs-baseline-对比" tabindex="-1">PGO vs Baseline 对比 <a class="header-anchor" href="#pgo-vs-baseline-对比" aria-label="Permalink to “PGO vs Baseline 对比”">​</a></h3><table tabindex="0"><thead><tr><th>指标</th><th>Baseline</th><th>PGO Optimized</th><th>变化</th></tr></thead><tbody><tr><td>编译时间</td><td>3-5 分钟</td><td>38s</td><td><strong>-85%</strong></td></tr><tr><td>Code Area</td><td>~15 MB (估计)</td><td>10.51 MB</td><td><strong>-30%</strong></td></tr><tr><td>Image Heap</td><td>~20 MB (估计)</td><td>13.70 MB</td><td><strong>-31%</strong></td></tr><tr><td>总大小</td><td>36.88 MB</td><td>24.62 MB</td><td><strong>-33.2%</strong></td></tr><tr><td>启动时间</td><td>20ms</td><td>32ms</td><td><strong>+60%</strong></td></tr></tbody></table><h3 id="pgo-在解释器模式下的有效性" tabindex="-1">PGO 在解释器模式下的有效性 <a class="header-anchor" href="#pgo-在解释器模式下的有效性" aria-label="Permalink to “PGO 在解释器模式下的有效性”">​</a></h3><p><strong>预期 (JIT 模式)</strong>: PGO 优化热路径,提升峰值性能 20-30%</p><p><strong>实际 (解释器模式)</strong>: PGO 主要收益是大小优化,性能提升有限</p><p><strong>原因</strong>:</p><ul><li>解释器模式下,热路径是解释循环本身,而非业务逻辑</li><li>PGO 基于 profile 数据优化,但业务逻辑未被 JIT 编译</li><li>主要收益转化为代码消除,而非代码优化</li></ul><p><strong>未来改进</strong>: 修复 Truffle runtime 启用 Graal JIT 后,PGO 将同时优化大小和性能</p><h2 id="性能优化建议" tabindex="-1">性能优化建议 <a class="header-anchor" href="#性能优化建议" aria-label="Permalink to “性能优化建议”">​</a></h2><h3 id="短期-当前可用" tabindex="-1">短期 (当前可用) <a class="header-anchor" href="#短期-当前可用" aria-label="Permalink to “短期 (当前可用)”">​</a></h3><ol><li><strong>使用 PGO 优化二进制大小</strong> (-33.2%)</li><li><strong>容器化部署使用 Native Image</strong> (启动 100-500x 提升)</li><li><strong>Serverless 场景强烈推荐 Native Image</strong> (冷启动优化)</li></ol><h3 id="中期-需要修复-truffle-runtime" tabindex="-1">中期 (需要修复 Truffle Runtime) <a class="header-anchor" href="#中期-需要修复-truffle-runtime" aria-label="Permalink to “中期 (需要修复 Truffle Runtime)”">​</a></h3><ol><li><p><strong>启用 Graal JIT 编译器</strong></p><ul><li>移除 <code>-Dtruffle.TruffleRuntime</code> 显式配置</li><li>验证 Graal compiler 可用</li><li>重新测试峰值性能</li></ul></li><li><p><strong>重新执行 PGO 流程</strong></p><ul><li>使用生产负载收集 profile</li><li>预期峰值性能提升 20-30%</li></ul></li></ol><h3 id="长期-phase-2-truffle-dsl-优化" tabindex="-1">长期 (Phase 2 - Truffle DSL 优化) <a class="header-anchor" href="#长期-phase-2-truffle-dsl-优化" aria-label="Permalink to “长期 (Phase 2 - Truffle DSL 优化)”">​</a></h3><ol><li><p><strong>实施 Truffle DSL 高级优化</strong></p><ul><li>参考 ROADMAP Phase 2 Tasks 2.1-2.5</li><li>优化节点特化和内联策略</li></ul></li><li><p><strong>探索额外 Native Image 优化</strong></p><ul><li><code>-march=native</code>: CPU 特定优化</li><li><code>--future-defaults=all</code>: 使用未来默认配置</li></ul></li></ol><h2 id="数据来源" tabindex="-1">数据来源 <a class="header-anchor" href="#数据来源" aria-label="Permalink to “数据来源”">​</a></h2><p>本报告数据来源于:</p><ul><li><code>.claude/phase5-task5.1-pgo-report.md</code> (PGO 性能测试)</li><li><code>.claude/phase5-task5.2-size-optimization-report.md</code> (大小优化分析)</li><li><code>/tmp/phase5-pgo-instrument-build.log</code> (Instrumented 编译日志)</li><li><code>/tmp/phase5-pgo-optimized-build.log</code> (Optimized 编译日志)</li><li><code>/tmp/phase5-pgo-performance.txt</code> (性能测试结果)</li><li>Phase 3D 和 Task 4.3 基准测试数据</li></ul><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to “结论”">​</a></h2><p><strong>Native Image 核心价值</strong>: 启动速度和资源占用,而非峰值吞吐量</p><p><strong>最佳实践</strong>:</p><ul><li><strong>短生命周期任务</strong>: Native Image (CLI, 脚本, Serverless)</li><li><strong>长时间运行服务</strong>: JVM (Web 服务器, 后台任务)</li><li><strong>容器化部署</strong>: Native Image PGO (成本优化)</li></ul><p><strong>当前限制</strong>: Truffle fallback runtime 限制峰值性能,待修复</p><p><strong>未来展望</strong>: 修复 runtime + PGO 将同时优化大小和性能</p><h2 id="相关文档" tabindex="-1">相关文档 <a class="header-anchor" href="#相关文档" aria-label="Permalink to “相关文档”">​</a></h2><ul><li><a href="./README.html">快速开始</a></li><li><a href="./build-guide.html">详细构建指南</a></li><li><a href="./troubleshooting.html">故障排查</a></li><li><a href="./limitations.html">限制说明</a></li></ul>`,113)])])}const b=a(l,[["render",r]]);export{c as __pageData,b as default};
