import{_ as t,c as a,o as s,aj as i}from"./chunks/framework.Bz2R-749.js";const h=JSON.parse('{"title":"JVM Interop Overloads","description":"","frontmatter":{"title":"JVM Interop Overloads"},"headers":[],"relativePath":"guide/interop-overloads.md","filePath":"guide/interop-overloads.md"}'),n={name:"guide/interop-overloads.md"};function l(o,e,d,r,c,p){return s(),a("div",null,[...e[0]||(e[0]=[i(`<h1 id="jvm-interop-overloads" tabindex="-1">JVM Interop Overloads <a class="header-anchor" href="#jvm-interop-overloads" aria-label="Permalink to “JVM Interop Overloads”">​</a></h1><p>This page explains how Aster chooses a Java overload for static calls and how you can disambiguate when needed.</p><h2 id="policy-summary" tabindex="-1">Policy (summary) <a class="header-anchor" href="#policy-summary" aria-label="Permalink to “Policy (summary)”">​</a></h2><ul><li>Match by arity.</li><li>Prefer exact primitive matches (I, J, D, Z), then primitive widening: <ul><li>Int → Long, Double; Long → Double</li></ul></li><li>Prefer boxed types (Integer/Long/Double/Number) over <code>Object</code> when primitives don’t match.</li><li>Core <code>Number</code> maps to JVM <code>java.lang.Double</code>. For Java callsites in examples, prefer <code>aster.runtime.Primitives.number(…)</code> to construct values.</li><li>Prefer <code>String</code>/<code>CharSequence</code> for text.</li><li>Varargs are considered with the component type.</li><li>Ties are broken by a scoring heuristic; the emitter also attempts reflection against classes on the classpath to select the exact descriptor. If reflection is not available, a heuristic is used.</li></ul><h2 id="disambiguation" tabindex="-1">Disambiguation <a class="header-anchor" href="#disambiguation" aria-label="Permalink to “Disambiguation”">​</a></h2><p>Use literal suffixes to make intent explicit:</p><ul><li><code>1</code> is <code>Int</code> (I)</li><li><code>1L</code> is <code>Long</code> (J)</li><li><code>1.0</code> is <code>Double</code> (D)</li></ul><p>For example, given <code>Interop.sum(int,int)</code>, <code>Interop.sum(long,long)</code>, and <code>Interop.sum(double,double)</code>:</p><ul><li><code>Interop.sum(1, 2)</code> → picks <code>(II)</code></li><li><code>Interop.sum(1L, 2L)</code> → picks <code>(JJ)</code></li><li><code>Interop.sum(1.0, 2.0)</code> → picks <code>(DD)</code></li><li>Mixed: <ul><li><code>Interop.sum(1, 2L)</code> → widens to <code>(JJ)</code></li><li><code>Interop.sum(1, 2.0)</code> → widens to <code>(DD)</code></li></ul></li></ul><p>The LSP highlights ambiguous calls that mix numeric kinds and offers a quick hint to use <code>1L</code> or <code>1.0</code>.</p><h2 id="diagnostics" tabindex="-1">Diagnostics <a class="header-anchor" href="#diagnostics" aria-label="Permalink to “Diagnostics”">​</a></h2><ul><li>When multiple overloads tie after scoring, the emitter logs an ambiguity note and the selected descriptor.</li><li>When no primitive signals are present (e.g., only <code>Object</code>/<code>String</code> arguments), the emitter logs that a heuristic was used. Set <code>DIAG_OVERLOAD=false</code> to silence.</li></ul><h3 id="nullability-defaults-overrides" tabindex="-1">Nullability Defaults/Overrides <a class="header-anchor" href="#nullability-defaults-overrides" aria-label="Permalink to “Nullability Defaults/Overrides”">​</a></h3><p>For common helpers, parameters are treated as non‑null unless documented otherwise. Highlights:</p><ul><li><code>Text.*</code>: all params are non‑null except <code>Text.equals(a,b)</code> which accepts nulls for both.</li><li><code>List.length(xs)</code>, <code>List.isEmpty(xs)</code>: <code>xs</code> non‑null. <code>List.get(xs,i)</code>: both non‑null.</li><li><code>Map.get(m,k)</code>: <code>m</code> non‑null, <code>k</code> may be null.</li><li><code>Map.containsKey(m,k)</code>: <code>m</code> non‑null, <code>k</code> may be null.</li><li><code>Set.contains/add/remove(s,x)</code>: <code>s</code> non‑null, <code>x</code> may be null.</li><li><code>Interop.sum(a,b)</code>: both non‑null.</li><li><code>Interop.pick(x)</code>: <code>x</code> may be null (Object overload will be chosen).</li></ul><p>The LSP flags calls that pass <code>null</code> to parameters marked as non‑null.</p><p>You can enable strict enforcement during class emission by setting:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>INTEROP_NULL_STRICT=true</span></span></code></pre></div><p>In strict mode, emitting a class for a call that passes <code>null</code> to a non‑null parameter throws an error and fails the build. Otherwise, a warning is printed to stderr and emission proceeds.</p><p>You can also provide a custom policy JSON to override defaults:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>INTEROP_NULL_POLICY=/absolute/path/to/interop-null-policy.json</span></span></code></pre></div><p>Example file (see docs/examples/interop-null-policy.json):</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;Text.equals&quot;: [true, true],</span></span>
<span class="line"><span>  &quot;Text.concat&quot;: [false, false],</span></span>
<span class="line"><span>  &quot;Map.get&quot;: [false, true]</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Each entry lists, per parameter (in order), whether <code>null</code> is allowed (<code>true</code>) or not (<code>false</code>).</p><p>Smoke test for strict mode:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>npm run build</span></span>
<span class="line"><span>npm run verify:asm:nullstrict   # expects failure in strict mode for Text.length(null)</span></span></code></pre></div><h3 id="quick-fix-defaults-lsp" tabindex="-1">Quick Fix Defaults (LSP) <a class="header-anchor" href="#quick-fix-defaults-lsp" aria-label="Permalink to “Quick Fix Defaults (LSP)”">​</a></h3><p>When the LSP detects a null passed to a non‑null parameter, it offers a Quick Fix tailored to common methods:</p><table tabindex="0"><thead><tr><th>Method</th><th style="text-align:center;">Param</th><th>Suggested default</th></tr></thead><tbody><tr><td>Text.split(h, sep)</td><td style="text-align:center;">2</td><td>&quot; &quot;</td></tr><tr><td>Text.startsWith(h, p)</td><td style="text-align:center;">1/2</td><td>&quot;&quot;</td></tr><tr><td>Text.endsWith(h, s)</td><td style="text-align:center;">1/2</td><td>&quot;&quot;</td></tr><tr><td>Text.indexOf(h, n)</td><td style="text-align:center;">2</td><td>&quot; &quot;</td></tr><tr><td>Text.contains(h, n)</td><td style="text-align:center;">2</td><td>&quot;&quot;</td></tr><tr><td></td><td style="text-align:center;">1</td><td>&quot;&quot;</td></tr><tr><td>Text.replace(h, t, r)</td><td style="text-align:center;">any</td><td>&quot;&quot;</td></tr><tr><td>Text.toUpper(h)</td><td style="text-align:center;">1</td><td>&quot;&quot;</td></tr><tr><td>Text.toLower(h)</td><td style="text-align:center;">1</td><td>&quot;&quot;</td></tr><tr><td>Text.length(h)</td><td style="text-align:center;">1</td><td>&quot;&quot;</td></tr><tr><td>Text.concat(a, b)</td><td style="text-align:center;">any</td><td>&quot;&quot;</td></tr><tr><td>List.get(xs, i)</td><td style="text-align:center;">2</td><td>0</td></tr><tr><td>Interop.sum(a, b)</td><td style="text-align:center;">any</td><td>0</td></tr><tr><td>Map.get(m, k)</td><td style="text-align:center;">2</td><td>&quot;&quot;</td></tr><tr><td>Map.containsKey(m, k)</td><td style="text-align:center;">2</td><td>&quot;&quot;</td></tr><tr><td>Set.contains(s, x)</td><td style="text-align:center;">2</td><td>&quot;&quot;</td></tr><tr><td>Set.add(s, x)</td><td style="text-align:center;">2</td><td>&quot;&quot;</td></tr><tr><td>Set.remove(s, x)</td><td style="text-align:center;">2</td><td>&quot;&quot;</td></tr><tr><td>Interop.pick(x)</td><td style="text-align:center;">1</td><td>&quot;&quot;</td></tr></tbody></table><p>These defaults are conservative and intended to help quickly reach a valid state. You should review the replacement to ensure it matches your intended semantics.</p><h3 id="lightweight-method-cache" tabindex="-1">Lightweight Method Cache <a class="header-anchor" href="#lightweight-method-cache" aria-label="Permalink to “Lightweight Method Cache”">​</a></h3><p>The ASM emitter maintains a small cache of method descriptors under <code>build/.asteri/method-cache.json</code>. It is populated when reflection succeeds and used as a fallback when reflection is unavailable (e.g., restricted environments).</p><ul><li>Inspect cache: <code>npm run cache:inspect:methods</code></li><li>Clear cache: <code>npm run cache:clear:methods</code></li></ul><p>This improves stability and avoids repeated reflection during development. It is not a full classpath index.</p><h2 id="examples" tabindex="-1">Examples <a class="header-anchor" href="#examples" aria-label="Permalink to “Examples”">​</a></h2><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>This module is demo.examples.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To demoSum, produce Text:</span></span>
<span class="line"><span>  Return Interop.sum(1, 2L).  // widens to (JJ)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To demoSum2, produce Text:</span></span>
<span class="line"><span>  Return Interop.sum(1, 2.0). // widens to (DD)</span></span></code></pre></div><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>To pickKinds, produce Text:</span></span>
<span class="line"><span>  Return Interop.pick(1L). // (J)</span></span></code></pre></div><h3 id="java-interop-helpers" tabindex="-1">Java interop helpers <a class="header-anchor" href="#java-interop-helpers" aria-label="Permalink to “Java interop helpers”">​</a></h3><p>When constructing values from Java for fields or parameters typed as Aster <code>Number</code>, use the utility methods in <code>aster.runtime.Primitives</code> for clarity and consistency:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>// timeOfDay is an Aster Number (emits as java.lang.Double)</span></span>
<span class="line"><span>var ctx = new demo.policy.PolicyContext(</span></span>
<span class="line"><span>  userId, userRole, owner, demo.policy.Resource.Document,</span></span>
<span class="line"><span>  aster.runtime.Primitives.number(14.5),</span></span>
<span class="line"><span>  &quot;office&quot;);</span></span></code></pre></div><p>Available helpers:</p><ul><li><code>Primitives.number(double) -&gt; Double</code></li><li><code>Primitives.integer(int) -&gt; Integer</code></li><li><code>Primitives.longNum(long) -&gt; Long</code></li><li><code>Primitives.bool(boolean) -&gt; Boolean</code></li></ul>`,42)])])}const m=t(n,[["render",l]]);export{h as __pageData,m as default};
