import{_ as a,c as o,o as d,aj as l}from"./chunks/framework.Bz2R-749.js";const m=JSON.parse('{"title":"变量流动分析","description":"","frontmatter":{},"headers":[],"relativePath":"workstreams/truffle-phase2/variable-flow-analysis.md","filePath":"workstreams/truffle-phase2/variable-flow-analysis.md"}'),c={name:"workstreams/truffle-phase2/variable-flow-analysis.md"};function i(r,e,t,n,s,h){return d(),o("div",null,[...e[0]||(e[0]=[l('<h1 id="变量流动分析" tabindex="-1">变量流动分析 <a class="header-anchor" href="#变量流动分析" aria-label="Permalink to “变量流动分析”">​</a></h1><blockquote><p>更新时间：2025-11-02 23:35 NZST｜执行者：Codex</p></blockquote><h2 id="_1-当前架构" tabindex="-1">1. 当前架构 <a class="header-anchor" href="#_1-当前架构" aria-label="Permalink to “1. 当前架构”">​</a></h2><h3 id="env-数据结构" tabindex="-1">Env 数据结构 <a class="header-anchor" href="#env-数据结构" aria-label="Permalink to “Env 数据结构”">​</a></h3><ul><li>基于 <code>HashMap&lt;String, Object&gt;</code> 保存名称到值的映射。</li><li><code>Loader</code> 在 <code>buildProgramInternal</code> 中创建唯一的 <code>Env</code> 实例，并在构建语法树时注入到各个节点。</li><li>所有语法节点共享同一个 <code>Env</code>；不存在父作用域链或嵌套环境。</li><li>不携带类型信息或作用域元数据，完全运行时动态解析。</li></ul><h3 id="变量分类" tabindex="-1">变量分类 <a class="header-anchor" href="#变量分类" aria-label="Permalink to “变量分类”">​</a></h3><ol><li><p><strong>参数变量</strong></p><ul><li>来源：函数形参，在 <code>CoreModel.Func</code> 转换过程中产生。</li><li>作用域：<code>LambdaValue.apply</code> 执行期间，以 <code>env.set(param, arg)</code> 注入，同步保存旧值以便恢复。</li><li>当前实现：<code>Loader</code> 在 <code>CallNode</code> 构建前将参数名写入 <code>Env</code>（初始化为 <code>null</code>），调用时由 <code>LambdaValue</code> 绑定并在返回后恢复旧值。</li><li>读取方式：<code>NameNode.execute</code> 直接从共享 <code>Env</code> 中取值，属于动态作用域读取。</li></ul></li><li><p><strong>局部变量</strong></p><ul><li>来源：<code>Let</code> 语句以及 <code>Match</code> 模式绑定。</li><li>作用域：缺乏显式生命周期管理，绑定后留在全局 <code>Env</code>，可能被后续语句覆盖。</li><li>当前实现：<code>LetNode.execute</code> 将初始值绑定到 <code>Env</code>；<code>MatchNode.PatCtorNode</code> 在匹配成功时调用 <code>env.set</code> 绑定模式变量；无自动清理。</li><li>读取方式：后续 <code>NameNode</code> 调用同名变量即获取。</li></ul></li><li><p><strong>闭包变量</strong></p><ul><li>来源：<code>CoreModel.Lambda</code> 的 <code>captures</code> 列表，以及函数定义捕获的外部名称。</li><li>作用域：保存在 <code>LambdaValue.captures</code> 的 <code>Map</code> 中，同时 <code>LambdaValue</code> 仍持有对全局 <code>Env</code> 的引用。</li><li>当前实现：<code>Loader.buildExpr</code> 在创建 <code>LiteralNode(new LambdaValue(...))</code> 时预先读取当前 <code>Env</code> 中的捕获值并存入 <code>captures</code>；在调用 <code>apply</code> 时，先保存旧值，再写入捕获值，执行后恢复旧值。</li></ul></li></ol><h2 id="_2-变量读写模式" tabindex="-1">2. 变量读写模式 <a class="header-anchor" href="#_2-变量读写模式" aria-label="Permalink to “2. 变量读写模式”">​</a></h2><h3 id="namenode-读取" tabindex="-1">NameNode（读取） <a class="header-anchor" href="#namenode-读取" aria-label="Permalink to “NameNode（读取）”">​</a></h3><ul><li>路径：<code>aster-truffle/nodes/NameNode.java</code>。</li><li>行为：忽略 <code>VirtualFrame</code>，直接对注入的 <code>Env</code> 调用 <code>env.get(name)</code>。</li><li>影响：无法区分变量类型；参数、局部以及全局函数名称全部通过同一映射解析。</li></ul><h3 id="letnode-绑定" tabindex="-1">LetNode（绑定） <a class="header-anchor" href="#letnode-绑定" aria-label="Permalink to “LetNode（绑定）”">​</a></h3><ul><li>路径：<code>aster-truffle/nodes/LetNode.java</code>。</li><li>行为：计算初始化表达式后调用 <code>env.set(name, value)</code>；无作用域清理。</li><li>特性：在 <code>AsterConfig.DEBUG</code> 时打印绑定日志；对同名变量进行覆盖写入。</li></ul><h3 id="setnode-赋值" tabindex="-1">SetNode（赋值） <a class="header-anchor" href="#setnode-赋值" aria-label="Permalink to “SetNode（赋值）”">​</a></h3><ul><li>路径：<code>aster-truffle/nodes/SetNode.java</code>。</li><li>行为：求值后执行 <code>env.set(name, value)</code>；若原变量不存在，会创建新条目。</li><li>影响：缺少未定义检查，赋值语句可能默默引入新变量。</li></ul><h3 id="callnode-调用" tabindex="-1">CallNode（调用） <a class="header-anchor" href="#callnode-调用" aria-label="Permalink to “CallNode（调用）”">​</a></h3><ul><li>路径：<code>aster-truffle/nodes/CallNode.java</code>。</li><li>行为：解析目标后区分 <code>LambdaValue</code> 与内建函数调用。</li><li>环境交互：调用 <code>LambdaValue.apply</code> 时传入共享的 <code>Env</code>；<code>CallNode</code> 本身不直接访问 <code>Env</code>，但通过 <code>NameNode</code> 解析函数名称与参数。</li></ul><h3 id="lambdavalue-闭包" tabindex="-1">LambdaValue（闭包） <a class="header-anchor" href="#lambdavalue-闭包" aria-label="Permalink to “LambdaValue（闭包）”">​</a></h3><ul><li>路径：<code>aster-truffle/nodes/LambdaValue.java</code>。</li><li>行为：在 <code>apply</code> 内保存当前 <code>Env</code> 中的捕获与形参旧值，写入新值执行体节点，最后统一恢复。</li><li>闭包模型：捕获值在创建时存入 <code>captures</code>，但执行仍依赖共享 <code>Env</code> 进行覆盖与恢复，属于动态环境模拟。</li></ul><h2 id="_3-frame-迁移策略" tabindex="-1">3. Frame 迁移策略 <a class="header-anchor" href="#_3-frame-迁移策略" aria-label="Permalink to “3. Frame 迁移策略”">​</a></h2><h3 id="槽位分配" tabindex="-1">槽位分配 <a class="header-anchor" href="#槽位分配" aria-label="Permalink to “槽位分配”">​</a></h3><ol><li><p><strong>编译期分配</strong></p><ul><li>形参槽位：根据函数签名顺序分配索引 <code>0..n-1</code>。</li><li>局部变量槽位：在语句解析阶段建立符号表，分配 <code>n..m-1</code>。</li><li>需要新的符号表结构记录名称到槽位的映射，以替换当前 <code>Env</code> 查表。</li></ul></li><li><p><strong>运行期访问</strong></p><ul><li><code>NameNode</code>：从 <code>VirtualFrame</code> 使用 <code>frame.getObject(slotIndex)</code> 获取。</li><li><code>LetNode</code>：通过 <code>frame.setObject(slotIndex, value)</code> 或者 <code>FrameSlot</code> API 写入。</li><li><code>SetNode</code>：与 <code>LetNode</code> 相同，执行赋值写入。</li></ul></li></ol><h3 id="闭包处理" tabindex="-1">闭包处理 <a class="header-anchor" href="#闭包处理" aria-label="Permalink to “闭包处理”">​</a></h3><ul><li>方案 A：使用 <code>MaterializedFrame</code> 捕获整个调用帧，简单直接但内存成本高。</li><li>方案 B：基于符号表对需要捕获的槽位进行拷贝，构建局部环境快照。</li><li>建议：迁移初期采用方案 A，优先保证行为一致，再优化为按需捕获。</li></ul><h2 id="_4-迁移步骤" tabindex="-1">4. 迁移步骤 <a class="header-anchor" href="#_4-迁移步骤" aria-label="Permalink to “4. 迁移步骤”">​</a></h2><ol><li>引入 <code>FrameSlotBuilder</code> 等工具，基于语义模型分配槽位并生成 <code>FrameDescriptor</code>。</li><li>修改 <code>NameNode</code> 使用帧槽位读取，移除对 <code>Env</code> 的依赖。</li><li>调整 <code>LetNode</code> 在执行时写入帧槽位，并在调试模式下打印槽位信息。</li><li>调整 <code>SetNode</code> 的赋值逻辑，兼容帧槽位及必要的未定义检查。</li><li>更新 <code>LambdaValue</code>，在闭包创建时捕获 <code>MaterializedFrame</code> 或槽位快照。</li><li>清理剩余节点中的 <code>Env</code> 注入逻辑，并在 <code>Loader</code> 中改为构建帧描述。</li></ol><h2 id="_5-风险点" tabindex="-1">5. 风险点 <a class="header-anchor" href="#_5-风险点" aria-label="Permalink to “5. 风险点”">​</a></h2><ul><li>共享 <code>Env</code> 的现有语义等同于动态作用域，迁移到 Truffle 帧需要确认是否保持既有覆盖行为。</li><li><code>MatchNode</code> 与 <code>StartNode</code> 等模式绑定节点需要同步迁移，防止槽位分配遗漏临时变量。</li><li>闭包恢复逻辑目前依赖 <code>Map</code> 顺序，转换为帧后需要确保恢复顺序与重入安全。</li><li>函数重入和递归依赖 <code>LambdaValue</code> 保存旧值，改用帧后必须验证递归场景无回归。</li></ul>',27)])])}const b=a(c,[["render",i]]);export{m as __pageData,b as default};
