import{_ as a,c as i,o as n,aj as e}from"./chunks/framework.Bz2R-749.js";const o=JSON.parse('{"title":"Effect Inference System: Technical Design Document","description":"","frontmatter":{},"headers":[],"relativePath":"tech-effect-inference-design.md","filePath":"tech-effect-inference-design.md"}'),t={name:"tech-effect-inference-design.md"};function l(p,s,h,r,c,k){return n(),i("div",null,[...s[0]||(s[0]=[e(`<h1 id="effect-inference-system-technical-design-document" tabindex="-1">Effect Inference System: Technical Design Document <a class="header-anchor" href="#effect-inference-system-technical-design-document" aria-label="Permalink to “Effect Inference System: Technical Design Document”">​</a></h1><h2 id="architecture-overview" tabindex="-1">Architecture Overview <a class="header-anchor" href="#architecture-overview" aria-label="Permalink to “Architecture Overview”">​</a></h2><p>The effect inference system in Aster uses constraint-based analysis to determine the effects of functions, with support for polymorphic effect variables.</p><h3 id="key-components" tabindex="-1">Key Components <a class="header-anchor" href="#key-components" aria-label="Permalink to “Key Components”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>┌─────────────────────────────────────────────────────┐</span></span>
<span class="line"><span>│                  Parser Layer                        │</span></span>
<span class="line"><span>│  (Parse effect annotations &amp; effect variables)       │</span></span>
<span class="line"><span>└──────────────────┬──────────────────────────────────┘</span></span>
<span class="line"><span>                   │</span></span>
<span class="line"><span>                   ▼</span></span>
<span class="line"><span>┌─────────────────────────────────────────────────────┐</span></span>
<span class="line"><span>│                Type System Layer                     │</span></span>
<span class="line"><span>│  (EffectVar type, type unification)                  │</span></span>
<span class="line"><span>└──────────────────┬──────────────────────────────────┘</span></span>
<span class="line"><span>                   │</span></span>
<span class="line"><span>                   ▼</span></span>
<span class="line"><span>┌─────────────────────────────────────────────────────┐</span></span>
<span class="line"><span>│              Effect Inference Layer                  │</span></span>
<span class="line"><span>│  ┌─────────────────────────────────────────────┐    │</span></span>
<span class="line"><span>│  │  EffectCollector (visitor pattern)          │    │</span></span>
<span class="line"><span>│  │  - Visit function bodies                    │    │</span></span>
<span class="line"><span>│  │  - Collect local effects                    │    │</span></span>
<span class="line"><span>│  │  - Build call constraints                   │    │</span></span>
<span class="line"><span>│  │  - Handle Lambda expressions                │    │</span></span>
<span class="line"><span>│  └─────────────────────────────────────────────┘    │</span></span>
<span class="line"><span>│  ┌─────────────────────────────────────────────┐    │</span></span>
<span class="line"><span>│  │  EffectPropagator                           │    │</span></span>
<span class="line"><span>│  │  - Build SCC graph (Tarjan&#39;s algorithm)     │    │</span></span>
<span class="line"><span>│  │  - Topological sort                         │    │</span></span>
<span class="line"><span>│  │  - Iterative fixpoint computation          │    │</span></span>
<span class="line"><span>│  │  - Effect binding propagation               │    │</span></span>
<span class="line"><span>│  └─────────────────────────────────────────────┘    │</span></span>
<span class="line"><span>│  ┌─────────────────────────────────────────────┐    │</span></span>
<span class="line"><span>│  │  DiagnosticBuilder                          │    │</span></span>
<span class="line"><span>│  │  - Detect missing effects                   │    │</span></span>
<span class="line"><span>│  │  - Detect redundant effects                 │    │</span></span>
<span class="line"><span>│  │  - Detect unresolved effect variables       │    │</span></span>
<span class="line"><span>│  └─────────────────────────────────────────────┘    │</span></span>
<span class="line"><span>└──────────────────┬──────────────────────────────────┘</span></span>
<span class="line"><span>                   │</span></span>
<span class="line"><span>                   ▼</span></span>
<span class="line"><span>┌─────────────────────────────────────────────────────┐</span></span>
<span class="line"><span>│               Module Cache Layer                     │</span></span>
<span class="line"><span>│  (Cross-module effect signatures &amp; invalidation)     │</span></span>
<span class="line"><span>└─────────────────────────────────────────────────────┘</span></span></code></pre></div><h2 id="data-structures" tabindex="-1">Data Structures <a class="header-anchor" href="#data-structures" aria-label="Permalink to “Data Structures”">​</a></h2><h3 id="effectref" tabindex="-1">EffectRef <a class="header-anchor" href="#effectref" aria-label="Permalink to “EffectRef”">​</a></h3><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectAtom</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Effect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Workflow&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectAtom</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">kind</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;EffectVar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span></code></pre></div><p>An <code>EffectRef</code> can be either:</p><ul><li>A concrete effect atom (PURE, CPU, IO, Workflow)</li><li>An effect variable (e.g., <code>{kind: &#39;EffectVar&#39;, name: &#39;E&#39;}</code>)</li></ul><h3 id="effectbinding" tabindex="-1">EffectBinding <a class="header-anchor" href="#effectbinding" aria-label="Permalink to “EffectBinding”">​</a></h3><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectBinding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectAtom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Current bound value</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  resolved</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Whether bound to non-PURE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>Tracks the binding state of an effect variable.</p><h3 id="effectbindingtable" tabindex="-1">EffectBindingTable <a class="header-anchor" href="#effectbindingtable" aria-label="Permalink to “EffectBindingTable”">​</a></h3><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectBindingTable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EffectBinding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//                             ↑funcName  ↑varName</span></span></code></pre></div><p>Maps functions to their effect variable bindings.</p><h3 id="effectconstraint" tabindex="-1">EffectConstraint <a class="header-anchor" href="#effectconstraint" aria-label="Permalink to “EffectConstraint”">​</a></h3><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectConstraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  caller</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Calling function name</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  callee</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Called function name</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Origin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Source location for diagnostics</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Represents a caller → callee dependency in the call graph.</p><h2 id="algorithm" tabindex="-1">Algorithm <a class="header-anchor" href="#algorithm" aria-label="Permalink to “Algorithm”">​</a></h2><h3 id="phase-1-effect-collection" tabindex="-1">Phase 1: Effect Collection <a class="header-anchor" href="#phase-1-effect-collection" aria-label="Permalink to “Phase 1: Effect Collection”">​</a></h3><p>For each function:</p><ol><li>Visit function body using EffectCollector visitor</li><li>Collect local effects from: <ul><li>Builtin calls (Http.get → IO, Analytics.compute → CPU)</li><li>Workflow statements (workflow → IO)</li><li>Lambda body effects (recursively)</li></ul></li><li>Record call constraints (caller → callee edges)</li></ol><p><strong>Pseudocode</strong>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>function collectEffects(func):</span></span>
<span class="line"><span>  localEffects = Set()</span></span>
<span class="line"><span>  constraints = []</span></span>
<span class="line"><span>  bindings = initBindings(func.effectParams)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  visitor = new EffectCollector(localEffects, constraints)</span></span>
<span class="line"><span>  visitor.visitBlock(func.body)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return {constraints, localEffects, bindings}</span></span></code></pre></div><h3 id="phase-2-constraint-graph-construction" tabindex="-1">Phase 2: Constraint Graph Construction <a class="header-anchor" href="#phase-2-constraint-graph-construction" aria-label="Permalink to “Phase 2: Constraint Graph Construction”">​</a></h3><p>Build a directed graph where:</p><ul><li><strong>Nodes</strong>: Function names</li><li><strong>Edges</strong>: Call relationships (constraints)</li></ul><p><strong>Pseudocode</strong>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>function buildGraph(constraints, effectMap):</span></span>
<span class="line"><span>  adjacency = Map&lt;string, Set&lt;string&gt;&gt;()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for constraint in constraints:</span></span>
<span class="line"><span>    if effectMap.has(constraint.callee):</span></span>
<span class="line"><span>      adjacency.get(constraint.caller).add(constraint.callee)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return adjacency</span></span></code></pre></div><h3 id="phase-3-scc-detection-tarjan-s-algorithm" tabindex="-1">Phase 3: SCC Detection (Tarjan&#39;s Algorithm) <a class="header-anchor" href="#phase-3-scc-detection-tarjan-s-algorithm" aria-label="Permalink to “Phase 3: SCC Detection (Tarjan&#39;s Algorithm)”">​</a></h3><p>Find strongly connected components (SCCs) to handle mutual recursion:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>function runTarjan(nodes, adjacency):</span></span>
<span class="line"><span>  index = 0</span></span>
<span class="line"><span>  stack = []</span></span>
<span class="line"><span>  visited = Map()</span></span>
<span class="line"><span>  components = []</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for node in nodes:</span></span>
<span class="line"><span>    if not visited.has(node):</span></span>
<span class="line"><span>      strongConnect(node)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return components</span></span></code></pre></div><h3 id="phase-4-effect-propagation" tabindex="-1">Phase 4: Effect Propagation <a class="header-anchor" href="#phase-4-effect-propagation" aria-label="Permalink to “Phase 4: Effect Propagation”">​</a></h3><p>Propagate effects through the call graph:</p><ol><li><strong>Seed bindings</strong>: Initialize effect variables with local effects</li><li><strong>Topological order</strong>: Process SCCs in reverse topological order</li><li><strong>SCC fixpoint</strong>: For each SCC, iterate until no changes</li><li><strong>Cross-SCC merge</strong>: Propagate effects between components</li></ol><p><strong>Pseudocode</strong>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>function propagateEffects(constraints, effectMap, bindings):</span></span>
<span class="line"><span>  seedBindings WithEffects(effectMap, bindings)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  {components, componentByNode} = runTarjan(nodes, adjacency)</span></span>
<span class="line"><span>  order = topologicalSort(components)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for componentIndex in order:</span></span>
<span class="line"><span>    members = components[componentIndex]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Intra-SCC fixpoint</span></span>
<span class="line"><span>    repeat until no changes:</span></span>
<span class="line"><span>      for node in members:</span></span>
<span class="line"><span>        for neighbor in members:</span></span>
<span class="line"><span>          mergeEffects(node, neighbor, effectMap, bindings)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Cross-SCC propagation</span></span>
<span class="line"><span>    for node in members:</span></span>
<span class="line"><span>      for neighbor not in same SCC:</span></span>
<span class="line"><span>        mergeEffects(node, neighbor, effectMap, bindings)</span></span></code></pre></div><h3 id="phase-5-diagnostic-generation" tabindex="-1">Phase 5: Diagnostic Generation <a class="header-anchor" href="#phase-5-diagnostic-generation" aria-label="Permalink to “Phase 5: Diagnostic Generation”">​</a></h3><p>Check for effect mismatches:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>function buildDiagnostics(funcs, effectMap, bindings):</span></span>
<span class="line"><span>  diagnostics = []</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for func in funcs:</span></span>
<span class="line"><span>    declared = func.effects</span></span>
<span class="line"><span>    inferred = resolveEffects(effectMap.get(func.name), bindings)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Check missing effects</span></span>
<span class="line"><span>    for effect in (inferred - declared):</span></span>
<span class="line"><span>      diagnostics.add(EFF_INFER_MISSING(func, effect))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Check redundant effects</span></span>
<span class="line"><span>    for effect in (declared - inferred):</span></span>
<span class="line"><span>      diagnostics.add(EFF_INFER_REDUNDANT(func, effect))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Check unresolved effect variables</span></span>
<span class="line"><span>    for varName in func.effectParams:</span></span>
<span class="line"><span>      binding = bindings.get(func.name).get(varName)</span></span>
<span class="line"><span>      if not binding.resolved:</span></span>
<span class="line"><span>        diagnostics.add(EFFECT_VAR_UNRESOLVED(func, varName))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return diagnostics</span></span></code></pre></div><h2 id="lambda-effect-handling" tabindex="-1">Lambda Effect Handling <a class="header-anchor" href="#lambda-effect-handling" aria-label="Permalink to “Lambda Effect Handling”">​</a></h2><h3 id="design-decision" tabindex="-1">Design Decision <a class="header-anchor" href="#design-decision" aria-label="Permalink to “Design Decision”">​</a></h3><p><strong>Strategy</strong>: Conservative propagation - Lambda body effects are collected immediately upon Lambda definition and contribute to the enclosing function&#39;s effects.</p><p><strong>Rationale</strong>:</p><ul><li>Simpler implementation without data-flow analysis</li><li>Ensures no effects are missed (soundness over precision)</li><li>Practical for most use cases</li></ul><h3 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to “Implementation”">​</a></h3><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// In EffectCollector.visitExpression</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e.kind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Lambda&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Core</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Lambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">visitBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lambda.body, context);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Lambda body processed, skip default recursion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to “Example”">​</a></h3><div class="language-aster"><button title="Copy Code" class="copy"></button><span class="lang">aster</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fn </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): Text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> IO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Let fetcher be </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> with</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">produce</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// IO effect collected here</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  Return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span></span></code></pre></div><p>Effect flow:</p><ol><li>EffectCollector visits <code>process</code> body</li><li>Encounters Lambda expression</li><li>Visits Lambda body, finds <code>Http.get</code> → adds IO to <code>process</code> effects</li><li>Result: <code>process</code> correctly inferred to require IO</li></ol><h2 id="cross-module-effect-propagation" tabindex="-1">Cross-Module Effect Propagation <a class="header-anchor" href="#cross-module-effect-propagation" aria-label="Permalink to “Cross-Module Effect Propagation”">​</a></h2><h3 id="module-cache-design" tabindex="-1">Module Cache Design <a class="header-anchor" href="#module-cache-design" aria-label="Permalink to “Module Cache Design”">​</a></h3><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectSignature</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> module</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> function</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> qualifiedName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> declared</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadonlySet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> inferred</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadonlySet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> required</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadonlySet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// declared ∪ inferred</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="caching-strategy" tabindex="-1">Caching Strategy <a class="header-anchor" href="#caching-strategy" aria-label="Permalink to “Caching Strategy”">​</a></h3><ol><li><strong>Write</strong>: After inferring effects, cache signatures by module</li><li><strong>Read</strong>: When analyzing module B that imports module A, load A&#39;s cached signatures</li><li><strong>Invalidation</strong>: When A changes, recursively invalidate A and all dependents</li></ol><p><strong>Pseudocode</strong>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>function cacheModuleEffects(moduleName, signatures, imports):</span></span>
<span class="line"><span>  effectSignaturesByModule.set(moduleName, signatures)</span></span>
<span class="line"><span>  updateDependencies(moduleName, imports)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function loadImportedEffects(context):</span></span>
<span class="line"><span>  for moduleName in context.imports:</span></span>
<span class="line"><span>    cached = getModuleEffectSignatures(moduleName)</span></span>
<span class="line"><span>    if cached:</span></span>
<span class="line"><span>      context.importedEffects.merge(cached)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function invalidateModuleEffects(moduleName):</span></span>
<span class="line"><span>  visited = Set()</span></span>
<span class="line"><span>  invalidateRecursive(moduleName, visited)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function invalidateRecursive(moduleName, visited):</span></span>
<span class="line"><span>  if visited.has(moduleName): return</span></span>
<span class="line"><span>  visited.add(moduleName)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  effectSignaturesByModule.delete(moduleName)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for dependent in dependentsByModule.get(moduleName):</span></span>
<span class="line"><span>    invalidateRecursive(dependent, visited)</span></span></code></pre></div><h2 id="effect-lattice" tabindex="-1">Effect Lattice <a class="header-anchor" href="#effect-lattice" aria-label="Permalink to “Effect Lattice”">​</a></h2><p>The effect hierarchy forms a lattice:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>        Workflow</span></span>
<span class="line"><span>           |</span></span>
<span class="line"><span>          IO</span></span>
<span class="line"><span>           |</span></span>
<span class="line"><span>          CPU</span></span>
<span class="line"><span>           |</span></span>
<span class="line"><span>         PURE</span></span></code></pre></div><p><strong>Comparison function</strong>:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">atom</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectAtom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (atom) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Effect.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PURE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Effect.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Effect.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Workflow</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strongerEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectAtom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectAtom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectAtom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="performance-characteristics" tabindex="-1">Performance Characteristics <a class="header-anchor" href="#performance-characteristics" aria-label="Permalink to “Performance Characteristics”">​</a></h2><h3 id="time-complexity" tabindex="-1">Time Complexity <a class="header-anchor" href="#time-complexity" aria-label="Permalink to “Time Complexity”">​</a></h3><ul><li><strong>Effect Collection</strong>: O(n) where n = number of AST nodes</li><li><strong>SCC Detection</strong>: O(V + E) where V = functions, E = calls (Tarjan&#39;s algorithm)</li><li><strong>Effect Propagation</strong>: O(V + E) × k where k = average SCC iterations (typically small)</li><li><strong>Overall</strong>: O(V + E) in practice</li></ul><h3 id="space-complexity" tabindex="-1">Space Complexity <a class="header-anchor" href="#space-complexity" aria-label="Permalink to “Space Complexity”">​</a></h3><ul><li><strong>Effect Map</strong>: O(V)</li><li><strong>Binding Table</strong>: O(V × P) where P = effect params per function</li><li><strong>Adjacency List</strong>: O(E)</li><li><strong>Overall</strong>: O(V + E)</li></ul><h3 id="optimization-opportunities" tabindex="-1">Optimization Opportunities <a class="header-anchor" href="#optimization-opportunities" aria-label="Permalink to “Optimization Opportunities”">​</a></h3><ol><li><strong>Incremental Analysis</strong>: Only re-analyze changed modules</li><li><strong>Effect Caching</strong>: Cache module-level effect signatures</li><li><strong>Lazy Propagation</strong>: Skip SCCs with no unresolved variables</li></ol><h2 id="error-codes" tabindex="-1">Error Codes <a class="header-anchor" href="#error-codes" aria-label="Permalink to “Error Codes”">​</a></h2><table tabindex="0"><thead><tr><th>Code</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>E101</td><td>EFF_INFER_MISSING_IO</td><td>Function performs IO but doesn&#39;t declare <code>It performs io</code></td></tr><tr><td>E102</td><td>EFF_INFER_MISSING_CPU</td><td>Function performs CPU but doesn&#39;t declare <code>It performs cpu</code></td></tr><tr><td>E103</td><td>EFF_INFER_REDUNDANT_IO</td><td>Function declares IO but doesn&#39;t perform any</td></tr><tr><td>E104</td><td>EFF_INFER_REDUNDANT_CPU</td><td>Function declares CPU but doesn&#39;t perform any</td></tr><tr><td>E210</td><td>EFFECT_VAR_UNDECLARED</td><td>Effect variable used but not declared in signature</td></tr><tr><td>E211</td><td>EFFECT_VAR_UNRESOLVED</td><td>Effect variable cannot be inferred to concrete effect</td></tr></tbody></table><h2 id="testing-strategy" tabindex="-1">Testing Strategy <a class="header-anchor" href="#testing-strategy" aria-label="Permalink to “Testing Strategy”">​</a></h2><h3 id="unit-tests" tabindex="-1">Unit Tests <a class="header-anchor" href="#unit-tests" aria-label="Permalink to “Unit Tests”">​</a></h3><ul><li>Effect collection (builtin calls, workflow, Lambda)</li><li>Constraint graph construction</li><li>SCC detection (mutual recursion, self-recursion)</li><li>Effect propagation (direct, transitive, diamond)</li><li>Effect variable binding</li><li>Cross-module propagation</li><li>Diagnostic generation</li></ul><h3 id="integration-tests" tabindex="-1">Integration Tests <a class="header-anchor" href="#integration-tests" aria-label="Permalink to “Integration Tests”">​</a></h3><ul><li>Complete type checking pipeline</li><li>LSP diagnostics and quick fixes</li><li>Multi-module projects</li></ul><h3 id="golden-tests" tabindex="-1">Golden Tests <a class="header-anchor" href="#golden-tests" aria-label="Permalink to “Golden Tests”">​</a></h3><ul><li>Canonical effect polymorphism examples</li><li>Regression test suite</li></ul><h2 id="future-enhancements" tabindex="-1">Future Enhancements <a class="header-anchor" href="#future-enhancements" aria-label="Permalink to “Future Enhancements”">​</a></h2><h3 id="_1-precise-lambda-effect-tracking" tabindex="-1">1. Precise Lambda Effect Tracking <a class="header-anchor" href="#_1-precise-lambda-effect-tracking" aria-label="Permalink to “1. Precise Lambda Effect Tracking”">​</a></h3><p>Current limitation: Lambda effects propagate immediately to enclosing function.</p><p><strong>Improvement</strong>: Track Lambda-to-variable bindings and analyze call sites:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Let f = lambda with x: ...  // Track: f → lambda</span></span>
<span class="line"><span>Call g(f)                    // Analyze: g&#39;s signature to determine f&#39;s effect usage</span></span></code></pre></div><h3 id="_2-effect-subtyping-constraints" tabindex="-1">2. Effect Subtyping Constraints <a class="header-anchor" href="#_2-effect-subtyping-constraints" aria-label="Permalink to “2. Effect Subtyping Constraints”">​</a></h3><p>Support constraints like <code>E &lt;: IO</code> (E must be at most IO):</p><div class="language-aster"><button title="Copy Code" class="copy"></button><span class="lang">aster</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fn limited </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> E</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x: Int with </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): Int </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // E can only be PURE, CPU, or IO (not Workflow)</span></span></code></pre></div><h3 id="_3-effect-inference-trace" tabindex="-1">3. Effect Inference Trace <a class="header-anchor" href="#_3-effect-inference-trace" aria-label="Permalink to “3. Effect Inference Trace”">​</a></h3><p>Provide detailed trace showing how effects were inferred:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Function &#39;outer&#39; inferred IO because:</span></span>
<span class="line"><span>  → calls &#39;inner&#39; (line 10)</span></span>
<span class="line"><span>    → calls &#39;Http.get&#39; (line 5)</span></span>
<span class="line"><span>      → builtin IO effect</span></span></code></pre></div><h3 id="_4-effect-capabilities-integration" tabindex="-1">4. Effect Capabilities Integration <a class="header-anchor" href="#_4-effect-capabilities-integration" aria-label="Permalink to “4. Effect Capabilities Integration”">​</a></h3><p>Unify effect variables with capability system for fine-grained control.</p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to “References”">​</a></h2><ol><li><strong>Type Systems</strong>: Pierce, Benjamin C. &quot;Types and Programming Languages&quot;</li><li><strong>Effect Systems</strong>: Lucassen, J.M. and Gifford, D.K. &quot;Polymorphic Effect Systems&quot;</li><li><strong>Tarjan&#39;s SCC</strong>: Tarjan, Robert. &quot;Depth-First Search and Linear Graph Algorithms&quot;</li><li><strong>Constraint Solving</strong>: Nielson, Flemming. &quot;Principles of Program Analysis&quot;</li></ol><h2 id="appendix-code-references" tabindex="-1">Appendix: Code References <a class="header-anchor" href="#appendix-code-references" aria-label="Permalink to “Appendix: Code References”">​</a></h2><ul><li><strong>Effect Inference</strong>: <code>src/effect_inference.ts</code></li><li><strong>Type System</strong>: <code>src/typecheck/type_system.ts</code></li><li><strong>Module Cache</strong>: <code>src/lsp/module_cache.ts</code></li><li><strong>Effect Signature</strong>: <code>src/effect_signature.ts</code></li><li><strong>Error Codes</strong>: <code>src/error_codes.ts</code></li><li><strong>Tests</strong>: <code>test/unit/effect/effect-inference.test.ts</code></li></ul>`,97)])])}const g=a(t,[["render",l]]);export{o as __pageData,g as default};
