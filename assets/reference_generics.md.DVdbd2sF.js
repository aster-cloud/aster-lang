import{_ as a,c as i,o as n,aj as s}from"./chunks/framework.Bz2R-749.js";const u=JSON.parse('{"title":"Parametric Polymorphism (Preview)","description":"","frontmatter":{},"headers":[],"relativePath":"reference/generics.md","filePath":"reference/generics.md"}'),r={name:"reference/generics.md"};function t(l,e,o,p,c,d){return n(),i("div",null,[...e[0]||(e[0]=[s(`<h1 id="parametric-polymorphism-preview" tabindex="-1">Parametric Polymorphism (Preview) <a class="header-anchor" href="#parametric-polymorphism-preview" aria-label="Permalink to “Parametric Polymorphism (Preview)”">​</a></h1><p>This document proposes a minimal, readable generics surface for Aster and the corresponding Core IR representation. The goal is to support generic types in user-defined data and function signatures with clear, CNL-style syntax.</p><h2 id="type-application" tabindex="-1">Type Application <a class="header-anchor" href="#type-application" aria-label="Permalink to “Type Application”">​</a></h2><ul><li>Syntax: <code>Foo of T</code> or <code>Pair of A and B</code>.</li><li>Multiple type arguments use <code>and</code> or commas.</li><li>Applies to any type constructor name (user data or library types).</li></ul><p>Examples:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Define a Box of T with value: T.</span></span>
<span class="line"><span>Define a Pair of A and B with left: A and right: B.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To left, with p: Pair of A and B, produce A:</span></span>
<span class="line"><span>  Return p.left.</span></span></code></pre></div><p>IR shape:</p><ul><li>AST: <code>TypeApp { base: &#39;Pair&#39;, args: [Type, ...] }</code></li><li>Core: <code>TypeApp { base: &#39;Pair&#39;, args: [Type, ...] }</code></li></ul><h2 id="type-variables" tabindex="-1">Type Variables <a class="header-anchor" href="#type-variables" aria-label="Permalink to “Type Variables”">​</a></h2><ul><li>Written as capital identifiers (e.g., <code>T</code>, <code>A</code>, <code>Key</code>).</li><li>In this preview, type variables are placeholders; inference and checking are limited.</li><li>Core includes <code>TypeVar</code> for future use; current typechecker treats unknowns permissively.</li></ul><h2 id="functions-future-phase" tabindex="-1">Functions (Future Phase) <a class="header-anchor" href="#functions-future-phase" aria-label="Permalink to “Functions (Future Phase)”">​</a></h2><ul><li>Function type parameters (implemented):</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>To identity of T, with x: T, produce T:</span></span>
<span class="line"><span>  Return x.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To first of A and B, with p: Pair of A and B, produce A:</span></span>
<span class="line"><span>  Return p.left.</span></span></code></pre></div><ul><li>Parsing attaches <code>typeParams: [&quot;T&quot;, ...]</code> to the function.</li><li>Lowering replaces any type name matching a type parameter with a Core <code>TypeVar</code>.</li><li>Typecheck diagnostics: <ul><li>Error if a type variable-like name is used but not declared: <ul><li>“Type variable-like &#39;U&#39; is used in &#39;foo&#39; but not declared; declare it with &#39;of U&#39;.”</li></ul></li><li>Warning if a declared type parameter is unused.</li></ul></li></ul><p>Inference (preview):</p><ul><li>The checker attempts a minimal unification from the return position to bind type variables (warnings on inconsistent inference).</li></ul><h2 id="typechecking-initial-behavior" tabindex="-1">Typechecking (Initial Behavior) <a class="header-anchor" href="#typechecking-initial-behavior" aria-label="Permalink to “Typechecking (Initial Behavior)”">​</a></h2><ul><li><code>TypeApp</code> participates in formatting and lowering; strict unification is future work.</li><li><code>TypeVar</code> prints as its name and is treated permissively in equality.</li></ul><h2 id="jvm-emission" tabindex="-1">JVM Emission <a class="header-anchor" href="#jvm-emission" aria-label="Permalink to “JVM Emission”">​</a></h2><ul><li>Unknown generics map to <code>Object</code> for now. Built-ins like <code>List</code> and <code>Map</code> already have dedicated mappings.</li></ul><h2 id="roadmap" tabindex="-1">Roadmap <a class="header-anchor" href="#roadmap" aria-label="Permalink to “Roadmap”">​</a></h2><ul><li>Add <code>typeParams</code> on functions and data declarations.</li><li>Add unification-based inference for <code>TypeVar</code> and <code>TypeApp</code>.</li><li>Enrich emitter with generic-aware bridges where applicable.</li></ul>`,22)])])}const m=a(r,[["render",t]]);export{u as __pageData,m as default};
