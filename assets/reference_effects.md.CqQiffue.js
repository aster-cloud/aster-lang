import{_ as a,c as i,o as s,aj as t}from"./chunks/framework.Bz2R-749.js";const h=JSON.parse('{"title":"Effects & Async (MVP)","description":"","frontmatter":{},"headers":[],"relativePath":"reference/effects.md","filePath":"reference/effects.md"}'),n={name:"reference/effects.md"};function c(o,e,r,l,d,p){return s(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="effects-async-mvp" tabindex="-1">Effects &amp; Async (MVP) <a class="header-anchor" href="#effects-async-mvp" aria-label="Permalink to “Effects &amp; Async (MVP)”">​</a></h1><p>Aster distinguishes between pure computation and effectful work using simple, readable annotations and a small set of control constructs for concurrency.</p><h2 id="declaring-effects" tabindex="-1">Declaring Effects <a class="header-anchor" href="#declaring-effects" aria-label="Permalink to “Declaring Effects”">​</a></h2><ul><li>Syntax (function header): <code>It performs IO</code>, <code>It performs CPU</code>, or both.</li><li>CNL-first capability syntax (accepted; checking planned): <code>It performs io with Http and Sql and Time.</code></li><li>Examples:</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>To fetch user with id: Text, produce Result of User or AuthErr. It performs IO:</span></span>
<span class="line"><span>  Return AuthRepo.load(id).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To checksum with bytes: List of Int, produce Int. It performs CPU:</span></span>
<span class="line"><span>  Return Crypto.hash(bytes).</span></span></code></pre></div><h2 id="enforcement-diagnostics-implemented" tabindex="-1">Enforcement &amp; Diagnostics (implemented) <a class="header-anchor" href="#enforcement-diagnostics-implemented" aria-label="Permalink to “Enforcement &amp; Diagnostics (implemented)”">​</a></h2><ul><li>Missing effect annotations are compile-time errors.</li><li>Minimal lattice: <code>∅ ⊑ CPU ⊑ IO[*]</code> (declaring <code>@io</code> satisfies CPU work).</li><li>Superfluous annotations: <code>@io</code> with only CPU-like work → info; <code>@cpu</code> with no CPU-like work → warning.</li><li>Detection currently uses a small prefix registry (<code>src/config/effects.ts</code>).</li></ul><h2 id="async-concurrency" tabindex="-1">Async Concurrency <a class="header-anchor" href="#async-concurrency" aria-label="Permalink to “Async Concurrency”">​</a></h2><p>Two constructs make async execution explicit and readable:</p><ul><li><code>Start x as async Expr.</code> begins an async task and binds a handle to <code>x</code>.</li><li><code>Wait for x and y.</code> waits for previously started tasks to complete.</li></ul><p>Example:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Within a scope:</span></span>
<span class="line"><span>  Start profile as async ProfileSvc.load(u.id).</span></span>
<span class="line"><span>  Start timeline as async FeedSvc.timeline(u.id).</span></span>
<span class="line"><span>  Wait for profile and timeline.</span></span>
<span class="line"><span>  Return Ok of Dash(profile, timeline).</span></span></code></pre></div><p>Guidance and lints:</p><ul><li>The typechecker warns if you <code>Start</code> tasks that are never <code>Wait</code>ed.</li><li><code>await(expr)</code> is an expression form; it expects <code>Maybe&lt;T&gt;</code> or <code>Result&lt;T,E&gt;</code> and yields <code>T</code>, otherwise a warning is emitted.</li><li>Async itself doesn’t imply IO; however, in practice async often wraps IO calls. The effects scan includes expressions under <code>Start</code>.</li></ul><h2 id="semantics-preview" tabindex="-1">Semantics (Preview) <a class="header-anchor" href="#semantics-preview" aria-label="Permalink to “Semantics (Preview)”">​</a></h2><ul><li>Effects are not enforced by the runtime; they are compile-time contracts and lints.</li><li>Async is structured: tasks are scoped to blocks; <code>Start</code> must be paired with a <code>Wait</code> to avoid leaks (the linter warns when not matched).</li><li>Evaluation order within a <code>Within a scope:</code> block is left-to-right for <code>Start</code> statements, with <code>Wait</code> establishing a join point.</li></ul><h2 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to “Configuration”">​</a></h2><ul><li>Tune detection by editing <code>src/config/effects.ts</code> to add prefixes that count as <code>IO</code> or <code>CPU</code> for your codebase.</li></ul><h2 id="future-work" tabindex="-1">Future Work <a class="header-anchor" href="#future-work" aria-label="Permalink to “Future Work”">​</a></h2><ul><li>Effect rows, propagation, and precise analysis.</li><li>Better async typing for task handles and structured <code>awaitAll</code> semantics.</li><li>Diagnostics for blocking operations in <code>@cpu</code> contexts.</li></ul>`,20)])])}const u=a(n,[["render",c]]);export{h as __pageData,u as default};
