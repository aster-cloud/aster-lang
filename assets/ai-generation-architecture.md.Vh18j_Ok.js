import{_ as s,c as i,o as a,aj as t}from"./chunks/framework.Bz2R-749.js";const k=JSON.parse('{"title":"AI 代码生成系统架构","description":"","frontmatter":{},"headers":[],"relativePath":"ai-generation-architecture.md","filePath":"ai-generation-architecture.md"}'),d={name:"ai-generation-architecture.md"};function o(n,e,r,l,c,h){return a(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="ai-代码生成系统架构" tabindex="-1">AI 代码生成系统架构 <a class="header-anchor" href="#ai-代码生成系统架构" aria-label="Permalink to “AI 代码生成系统架构”">​</a></h1><p>更新日期：2025-11-25 21:41 NZST · 执行者：Codex</p><h2 id="系统架构概览" tabindex="-1">系统架构概览 <a class="header-anchor" href="#系统架构概览" aria-label="Permalink to “系统架构概览”">​</a></h2><p>AI 代码生成体系横跨 CLI、核心 <code>src/ai</code> 模块以及系统化测试脚本。核心执行路径：用户在 CLI 中运行 <code>ai-generate</code> 命令 → <code>AIGenerator</code> 聚合 Prompt/Validator/Provider → <code>GenerationCache</code> 判定是否命中磁盘 → 未命中时调用 Provider 发起 LLM 请求 → 返回结果后写入缓存、进行政策验证并附加 provenance 元数据。系统化测试脚本以批量并发方式调用 CLI，并通过评估脚本生成 Markdown 报告。</p><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  CLI[&quot;./dist/scripts/aster.js ai-generate&quot;] --&gt; GEN[AIGenerator]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  GEN --&gt; PM[PromptManager]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  GEN --&gt; VAL[PolicyValidator]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  GEN --&gt; PROV[ProvenanceTracker]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  GEN --&gt; CACHE[GenerationCache]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  GEN --&gt; LLM[(LLMProvider)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  LLM --&gt; OAI[OpenAIProvider]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  LLM --&gt; ANT[AnthropicProvider]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  CACHE --&gt; FILES[&quot;.cache/ai-generation/*.json&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  TESTS[/run-systematic-tests.mjs/ ] --&gt;|Promise.all 调用| CLI</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  EVAL[scripts/evaluate-ai-generation.mjs] --&gt; REPORT[.claude/evaluation-report.md]</span></span></code></pre></div><h2 id="核心组件说明" tabindex="-1">核心组件说明 <a class="header-anchor" href="#核心组件说明" aria-label="Permalink to “核心组件说明”">​</a></h2><table tabindex="0"><thead><tr><th>组件</th><th>位置</th><th>责任</th></tr></thead><tbody><tr><td><code>AIGenerator</code></td><td><code>src/ai/generator.ts</code></td><td>管理 end-to-end 工作流：构建 prompt、调用 Provider、执行 <code>PolicyValidator</code>、注入 provenance，并负责缓存读写。</td></tr><tr><td><code>GenerationCache</code></td><td><code>src/ai/generation-cache.ts</code></td><td>根据 <code>\${provider}-\${model}-temp\${temperature}-fs\${fewShot}-\${hash(description)}</code> 生成键，将 <code>GenerateResult</code> 以 JSON 写入 <code>.cache/ai-generation/</code>，记录 hits/misses。</td></tr><tr><td><code>LLMProvider</code> &amp; 实现</td><td><code>src/ai/llm-provider.ts</code>、<code>src/ai/providers/*.ts</code></td><td>定义统一 <code>generate/getName/getModel</code> 接口，OpenAI/Anthropic 各自封装 API Key、模型参数与错误转换 (<code>LLMError</code>)。</td></tr><tr><td><code>PromptManager</code></td><td><code>src/ai/prompt-manager.ts</code></td><td>提供系统提示与 Few-shot 示例，具备内存缓存避免重复 I/O。</td></tr><tr><td><code>PolicyValidator</code></td><td><code>src/ai/validator.ts</code></td><td>对生成代码进行静态校验，输出 diagnostics，CLI 在终端展示结果。</td></tr><tr><td><code>ProvenanceTracker</code></td><td><code>src/ai/provenance.ts</code></td><td>在生成代码头部写入 provider/model/timestamp/validated 状态，便于审计。</td></tr><tr><td><code>ai-generate</code> CLI</td><td><code>src/cli/commands/ai-generate.ts</code> + <code>scripts/aster.ts</code></td><td>解析选项 (<code>--provider</code>, <code>--model</code>, <code>--few-shot-count</code>, <code>--temperature</code>, <code>--output</code>, <code>--no-cache</code>)，调用 <code>AIGenerator</code> 并展示缓存状态。</td></tr><tr><td>Systematic Tests</td><td><code>/tmp/run-systematic-tests.mjs</code></td><td>以并发=3 运行 <code>dev.jsonl</code> 用例，输出 JSON 结果与实时进度，供 Phase 3.4 性能验证。</td></tr><tr><td>评估脚本</td><td><code>scripts/evaluate-ai-generation.mjs</code></td><td>解析测试 JSON，生成表格化指标、失败列表与结论，写入 <code>.claude/evaluation-report.md</code>。</td></tr></tbody></table><h2 id="缓存机制详解" tabindex="-1">缓存机制详解 <a class="header-anchor" href="#缓存机制详解" aria-label="Permalink to “缓存机制详解”">​</a></h2><ul><li><strong>键生成</strong>：<code>AIGenerator.buildCacheKey()</code> 组合 provider 名称、模型、温度、Few-shot 数量与描述 SHA-256，避免文件名过长。</li><li><strong>存储策略</strong>：<code>GenerationCache.set()</code> 使用临时文件 + <code>rename</code> 原子写入，确保在并发写入时不会得到半成品；目录结构 <code>.cache/ai-generation/&lt;key&gt;.json</code> 可直接备份或同步。</li><li><strong>负载特征</strong>：Phase 3.4 首次运行写入 10 个缓存文件，命中率 62.5%（10/16），第二轮命中后单个用例耗时 &lt;1s。</li><li><strong>统计</strong>：<code>getCacheStats()</code> 暴露 hits/misses/hitRate，CLI 转发 <code>⚡ 緩存狀態</code>，系统化脚本可据此评估缓存收益。</li><li><strong>清理策略</strong>：目前无 TTL，推荐在 CI 中使用 <code>find .cache/ai-generation -mtime +7 -delete</code> 按时间清理，或根据项目需求实现 LRU。</li></ul><h2 id="并发执行机制" tabindex="-1">并发执行机制 <a class="header-anchor" href="#并发执行机制" aria-label="Permalink to “并发执行机制”">​</a></h2><p>Phase 3.4 的 <code>/tmp/run-systematic-tests.mjs</code> 使用 Promise 批调度：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CONCURRENCY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runBatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> slice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">splice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CONCURRENCY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(slice.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(runSingleTest));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>任务调度</strong>：根据 <code>dev.jsonl</code> 切片构建批次，<code>Promise.all</code> 同步等待，保证最短 wall-clock 时间。</li><li><strong>错误处理</strong>：包裹在 <code>try/catch</code> 中，记录 <code>FAILED</code> 与 <code>ERROR</code> 状态；429 错误直接保留在 JSON <code>reason</code> 字段，由评估脚本格式化。</li><li><strong>进度追踪</strong>：使用 <code>ora</code> spinner 打印 <code>[passed/total]</code>、<code>✓/✗/⚠/⚡</code> 四类统计。</li><li><strong>Rate limit 控制</strong>：通过限制 <code>CONCURRENCY=3</code> 以及第二轮缓存命中机制，将 token 消耗控制在 30k TPM 阈值以内，如遇 429 则需按 Phase 3.4 建议手动重试或降低并发。</li></ul><h2 id="扩展性设计" tabindex="-1">扩展性设计 <a class="header-anchor" href="#扩展性设计" aria-label="Permalink to “扩展性设计”">​</a></h2><ol><li><strong>添加新 Provider</strong><ul><li>创建 <code>src/ai/providers/&lt;name&gt;.ts</code>，实现 <code>LLMProvider</code> 接口及 <code>LLMError</code> 包装。</li><li>在 <code>scripts/aster.ts</code> 的 <code>ai-generate</code> 命令中注册 <code>--provider &lt;name&gt;</code>，并在 <code>createProvider()</code> 中实例化。</li><li>若 Provider 支持自定义参数，可在 CLI <code>option()</code> 中暴露额外 flag。</li></ul></li><li><strong>扩展缓存后端</strong><ul><li>新建类实现与 <code>GenerationCache</code> 相同接口（<code>get/set/clear/getCacheStats</code>），在 <code>AIGenerator</code> 构造函数注入即可支持例如 Redis/S3。</li></ul></li><li><strong>加入更多 Few-shot 变体</strong><ul><li><code>PromptManager</code> 读取 <code>prompts/few-shot-examples.jsonl</code>，可根据类别或标签选择子集，以 <code>fewShotCount</code> 控制混合策略。</li></ul></li><li><strong>评估工作流复用</strong><ul><li><code>scripts/evaluate-ai-generation.mjs</code> 接口接收任意 JSON 路径，可在 CI 中对不同分支输出多份报告并归档。</li></ul></li></ol><h2 id="设计准则" tabindex="-1">设计准则 <a class="header-anchor" href="#设计准则" aria-label="Permalink to “设计准则”">​</a></h2><ul><li><strong>解耦</strong>：CLI、核心生成、缓存、测试、评估互相通过清晰接口沟通，便于替换实现。</li><li><strong>可观测性</strong>：缓存统计、验证结果、Token Usage 均直接暴露，支撑 Phase 3.4 的 81.3% 准确率基线。</li><li><strong>可扩展性</strong>：Promise 并发与磁盘缓存均基于配置，满足从个人实验到批量评估的不同需求。</li></ul>`,17)])])}const g=s(d,[["render",o]]);export{k as __pageData,g as default};
