import{_ as i,c as a,o as t,aj as l}from"./chunks/framework.Bz2R-749.js";const h=JSON.parse('{"title":"Capability-Parameterized Effects (Design)","description":"","frontmatter":{},"headers":[],"relativePath":"reference/effects-capabilities.md","filePath":"reference/effects-capabilities.md"}'),o={name:"reference/effects-capabilities.md"};function r(s,e,c,n,d,p){return t(),a("div",null,[...e[0]||(e[0]=[l('<h1 id="capability-parameterized-effects-design" tabindex="-1">Capability-Parameterized Effects (Design) <a class="header-anchor" href="#capability-parameterized-effects-design" aria-label="Permalink to “Capability-Parameterized Effects (Design)”">​</a></h1><p>Status: Design accepted; parsing enabled for CNL-first and bracket sugar; enforcement behind flag Owner: Compiler team</p><h2 id="goals" tabindex="-1">Goals <a class="header-anchor" href="#goals" aria-label="Permalink to “Goals”">​</a></h2><ul><li>Express intent about which I/O capabilities a function may use (Http, Sql, Time, Files, Secrets, AiModel, …).</li><li>Preserve the minimal lattice: ∅ ⊑ CPU ⊑ IO[*]. IO subsumes CPU.</li><li>Ship CNL-first syntax now; keep IR/backends backward-compatible; gate enforcement behind a feature flag.</li></ul><p>Non-goals (Phase 0):</p><ul><li>Parametric capability arguments (e.g., Http[method=POST]).</li><li>Cross-module capability inference.</li><li>Runtime enforcement.</li></ul><h2 id="surface-syntax-cnl-first" tabindex="-1">Surface syntax (CNL-first) <a class="header-anchor" href="#surface-syntax-cnl-first" aria-label="Permalink to “Surface syntax (CNL-first)”">​</a></h2><ul><li>Header clause remains the source of truth. Two notations (equivalent): <ul><li>Fully CNL: &quot;It performs io with Http and Sql and Time.&quot;</li><li>Bracket sugar: &quot;It performs io [Http, Sql, Time].&quot;</li></ul></li></ul><p>Notes:</p><ul><li>Capitalization of capability names is stylistic; parser accepts <code>Http</code>, <code>SQL</code>, <code>Time</code> as identifiers.</li><li>Capability list is optional; plain <code>It performs io.</code> is valid and means unconstrained IO.</li><li>Formatter: example files are normalized to bracket sugar when capability lists are present.</li></ul><h3 id="choosing-a-style" tabindex="-1">Choosing a style <a class="header-anchor" href="#choosing-a-style" aria-label="Permalink to “Choosing a style”">​</a></h3><ul><li>Prefer bracket sugar in headers when listing more than one capability: concise and unambiguous.</li><li>Use CNL form in prose-heavy examples or when teaching the language step-by-step.</li><li>Both forms are equivalent; the parser accepts either. The formatter normalizes example headers with lists to bracket sugar.</li></ul><p>Notes:</p><ul><li>Capitalization of capability names is stylistic; parser should accept <code>Http</code>, <code>SQL</code>, <code>Time</code> as identifiers.</li><li>Capability list is optional; plain <code>It performs IO.</code> still valid and means unconstrained IO.</li></ul><h2 id="ast-and-ir-representation" tabindex="-1">AST and IR representation <a class="header-anchor" href="#ast-and-ir-representation" aria-label="Permalink to “AST and IR representation”">​</a></h2><p>Current IR: <code>Func.effects: readonly Effect[]</code> with <code>Effect = IO | CPU</code>.</p><p>Additive metadata for backward compatibility:</p><ul><li>AST.Function: add optional <code>effectCaps?: { io?: string[] }</code>.</li><li>Core.Func: add optional <code>effectCaps?: { readonly io?: readonly string[] }</code>.</li></ul><p>Rationale:</p><ul><li>Keeps existing <code>effects</code> array unchanged (minimizes churn in emitters/tests).</li><li>Allows tools to opt-in to capability-aware behavior without breaking older code.</li></ul><h3 id="example-conceptual" tabindex="-1">Example (conceptual) <a class="header-anchor" href="#example-conceptual" aria-label="Permalink to “Example (conceptual)”">​</a></h3><h3 id="examples" tabindex="-1">Examples <a class="header-anchor" href="#examples" aria-label="Permalink to “Examples”">​</a></h3><ul><li><p>With capability list (CNL):</p><p>To ping, produce Text. It performs io with Http and Sql and Time: Return &quot;ok&quot;.</p></li><li><p>With capability list (brackets):</p><p>To ping, produce Text. It performs io [Http, Sql, Time]: Return &quot;ok&quot;.</p></li><li><p>Unconstrained IO (no list):</p></li></ul><h3 id="capability-registry" tabindex="-1">Capability registry <a class="header-anchor" href="#capability-registry" aria-label="Permalink to “Capability registry”">​</a></h3><p>The prefixes that map call sites to capabilities live in:</p><ul><li>src/config/effects.ts → CAPABILITY_PREFIXES <ul><li>Example mappings: Http → [&#39;Http.&#39;], Sql → [&#39;Db.&#39;, &#39;Sql.&#39;], Time → [&#39;Time.&#39;, &#39;Clock.&#39;], Files → [&#39;Files.&#39;, &#39;Fs.&#39;], Secrets → [&#39;Secrets.&#39;], AiModel → [&#39;Ai.&#39;]</li></ul></li></ul><p>默认会基于该表执行能力子集校验，可通过设置环境变量 ASTER_CAP_EFFECTS_ENFORCE=0 禁用；设置为 1 可显式保持开启。</p><h3 id="mixed-form-header-example" tabindex="-1">Mixed-form header example <a class="header-anchor" href="#mixed-form-header-example" aria-label="Permalink to “Mixed-form header example”">​</a></h3><p>The parser also accepts a mixed form combining <code>with</code> and bracket list:</p><p>To ping, produce Text. It performs io with [Http, Sql]: Return &quot;ok&quot;.</p><p>To ping, produce Text. It performs io: Return &quot;ok&quot;.</p><ul><li>CNL: &quot;It performs io with Http and Sql and Time.&quot;</li><li>AST/Core: <code>effects = [IO]</code>, <code>effectCaps.io = [&quot;Http&quot;, &quot;Sql&quot;, &quot;Time&quot;]</code>.</li></ul><h2 id="parser-changes" tabindex="-1">Parser changes <a class="header-anchor" href="#parser-changes" aria-label="Permalink to “Parser changes”">​</a></h2><ul><li>Extend effect list parsing to accept optional CNL clause after <code>io</code>: <ul><li>Grammar sketch (CNL form): <ul><li><code>It performs io (with Capability (and Capability)*)? .</code></li></ul></li><li>Bracket sugar is deferred until lexer exposes &#39;[&#39; &#39;]&#39;.</li></ul></li><li>The parser records capability identifiers but does not validate their existence or semantics.</li></ul><p>Status:</p><ul><li>Implemented: CNL form is accepted and captured; bracket sugar is tokenized and parsed (lexer supports &#39;[&#39; and &#39;]&#39;).</li></ul><h2 id="lowering" tabindex="-1">Lowering <a class="header-anchor" href="#lowering" aria-label="Permalink to “Lowering”">​</a></h2><ul><li>Pass through <code>effectCaps</code> from AST to Core.Func unchanged.</li><li>No changes to current Effect enum or downstream emitters.</li></ul><h2 id="typechecker" tabindex="-1">Typechecker <a class="header-anchor" href="#typechecker" aria-label="Permalink to “Typechecker”">​</a></h2><ul><li><p>默认行为（ASTER_CAP_EFFECTS_ENFORCE 未设置或不为 <code>&#39;0&#39;</code>）：</p><ul><li>维持最小效应格检查（缺失效应报错；IO ⊒ CPU）。</li><li>依据 <code>src/config/effects.ts</code> 中的映射收集函数体使用到的能力前缀（如 <code>Http</code>: [&quot;Http.&quot;, &quot;Fetch.&quot;], <code>Sql</code>: [&quot;Db.&quot;, &quot;Jdbc.&quot;], <code>Time</code>: [&quot;Time.&quot;, &quot;Clock.&quot;] 等）。</li><li>当函数头声明 <code>@io</code> 能力列表时校验 <code>usedCaps ⊆ declaredCaps</code>；未声明列表时视为不受限。</li><li>诊断类别： <ul><li>缺失能力：错误（<code>EFF_CAP_MISSING</code>）</li><li>头部多余能力：信息（<code>EFF_CAP_SUPERFLUOUS</code>）</li></ul></li></ul></li><li><p>禁用行为（ASTER_CAP_EFFECTS_ENFORCE=<code>&#39;0&#39;</code>）：</p><ul><li>仅执行最小效应格检查。</li><li><code>effectCaps</code> 元数据仍会传递，但不会触发能力子集校验。</li></ul></li></ul><h3 id="subsumption-and-join-future" tabindex="-1">Subsumption and join (future) <a class="header-anchor" href="#subsumption-and-join-future" aria-label="Permalink to “Subsumption and join (future)”">​</a></h3><ul><li>Within IO, treat capability sets with subset ordering: <ul><li><code>IO[A] ⊑ IO[B]</code> iff <code>A ⊆ B</code>.</li><li>Join: <code>IO[A] ⊔ IO[B] = IO[A ∪ B]</code>.</li></ul></li><li>Functions without a list are considered <code>IO[*]</code> (top). CPU remains below IO.</li></ul><h2 id="feature-flags" tabindex="-1">Feature flags <a class="header-anchor" href="#feature-flags" aria-label="Permalink to “Feature flags”">​</a></h2><ul><li><code>ASTER_CAP_EFFECTS=1</code><ul><li>Enable parsing and IR emission of <code>effectCaps</code> (safe; default can be ON).</li></ul></li><li><code>ASTER_CAP_EFFECTS_ENFORCE=0</code><ul><li>显式禁用类型检查阶段的能力子集校验（默认保持启用）。</li></ul></li></ul><h2 id="migration-compatibility" tabindex="-1">Migration &amp; compatibility <a class="header-anchor" href="#migration-compatibility" aria-label="Permalink to “Migration &amp; compatibility”">​</a></h2><ul><li>Backward-compatible: existing programs with <code>It performs IO/CPU</code> continue to work.</li><li>Capability lists are opt-in metadata until enforcement is enabled.</li><li>Tooling (LSP) can surface capability info in hovers and code actions without enforcing.</li></ul><h2 id="acceptance-criteria-for-this-design-slice" tabindex="-1">Acceptance criteria (for this design slice) <a class="header-anchor" href="#acceptance-criteria-for-this-design-slice" aria-label="Permalink to “Acceptance criteria (for this design slice)”">​</a></h2><ul><li>Parser accepts CNL capability lists and stores them in AST; bracket sugar tracked as TODO.</li><li>Lowering preserves <code>effectCaps</code> to Core.Func.</li><li>No enforcement by default; gated enforcement design is documented.</li><li>Add or update docs (this page; references in DESIGN.md) and at least one golden showing capability list in AST/CORE when we enable printing of metadata (optional).</li></ul><h2 id="open-questions" tabindex="-1">Open questions <a class="header-anchor" href="#open-questions" aria-label="Permalink to “Open questions”">​</a></h2><ul><li>Canonical names and casing for capability tags (Http vs HTTP).</li><li>Extensibility for parameterized capabilities (e.g., Http[method=POST]).</li><li>Interactions with effect polymorphism (<code>with E</code>) when E contains IO rows.</li></ul>',50)])])}const f=i(o,[["render",r]]);export{h as __pageData,f as default};
